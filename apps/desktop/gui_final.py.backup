#!/usr/bin/env python3
"""
Final Khorium MeshGen GUI
==========================

Polished features:
- Clean progress bars showing only percentages
- Green bars when complete
- All bars reach 100% properly
- Visual quality report overlay
- Working mesh display using parsed .msh data
- No jitter or text overflow

Dependencies:
    pip install PyQt5 vtk numpy pyvista
"""

import sys
import os
import json
import subprocess
import threading
import tempfile
import re
import logging
from pathlib import Path
from typing import Optional, Dict
from queue import Queue

# Set up file logging for debugging
log_file = "/tmp/meshgen_gui_debug.log"
logging.basicConfig(
    filename=log_file,
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filemode='w'  # Overwrite on each launch
)
logging.info("="*60)
logging.info("GUI Starting - Log initialized")
logging.info("="*60)

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QTextEdit, QProgressBar, QGroupBox,
    QSplitter, QFileDialog, QFrame, QScrollArea, QGridLayout,
    QCheckBox, QSizePolicy, QSlider, QSpinBox, QComboBox
)
from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QObject
from PyQt5.QtGui import QFont, QPalette, QColor

import vtk
from vtkmodules.qt.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor

# Paintbrush refinement imports
PAINTBRUSH_AVAILABLE = False
try:
    # Add paths for imports
    import sys
    from pathlib import Path as PathLib

    app_dir = PathLib(__file__).parent
    project_root = app_dir.parent.parent

    # Add to path if not already there
    if str(app_dir) not in sys.path:
        sys.path.insert(0, str(app_dir))
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))

    from paintbrush_widget import PaintbrushWidget
    from core.paintbrush_geometry import PaintbrushSelector
    from strategies.paintbrush_strategy import PaintbrushStrategy

    PAINTBRUSH_AVAILABLE = True
    print("✓ Paintbrush feature loaded successfully")
except ImportError as e:
    print(f"⚠ Paintbrush feature not available: {e}")
    import traceback
    traceback.print_exc()

# Custom VTK interactor style for better pan control
class CustomInteractorStyle(vtk.vtkInteractorStyleTrackballCamera):
    """
    Custom interactor style with improved pan controls and paintbrush support:
    - Left mouse: Rotate (or paint if paintbrush mode enabled)
    - Right mouse: Rotate (in paint mode) or Pan (in normal mode)
    - Middle mouse or Shift+Left: Pan (alternative)
    - Scroll wheel: Zoom
    """

    def __init__(self, parent=None):
        super().__init__()
        self.parent = parent
        self.painting_mode = False
        self.is_painting = False
        self.AddObserver("RightButtonPressEvent", self.right_button_press)
        self.AddObserver("RightButtonReleaseEvent", self.right_button_release)
        self.AddObserver("LeftButtonPressEvent", self.left_button_press)
        self.AddObserver("LeftButtonReleaseEvent", self.left_button_release)
        self.AddObserver("MouseMoveEvent", self.mouse_move)

    def right_button_press(self, obj, event):
        if self.painting_mode:
            # In paint mode, right mouse rotates
            self.OnLeftButtonDown()
        else:
            # In normal mode, right mouse pans
            self.OnMiddleButtonDown()
        return

    def right_button_release(self, obj, event):
        if self.painting_mode:
            # In paint mode, right mouse rotates
            self.OnLeftButtonUp()
        else:
            # In normal mode, right mouse pans
            self.OnMiddleButtonUp()
        return

    def left_button_press(self, obj, event):
        if self.painting_mode and self.parent:
            # Start painting - consume event to prevent rotation
            self.is_painting = True
            self.paint_at_cursor()
            # Abort event to prevent further processing
            obj.SetAbortFlag(1)
        else:
            # Normal rotate
            self.OnLeftButtonDown()

    def left_button_release(self, obj, event):
        if self.painting_mode:
            self.is_painting = False
            # Abort event
            obj.SetAbortFlag(1)
        else:
            self.OnLeftButtonUp()

    def mouse_move(self, obj, event):
        if self.painting_mode and self.is_painting and self.parent:
            # Continue painting while dragging - DON'T call OnMouseMove to prevent rotation
            self.paint_at_cursor()
            # Abort event to prevent camera rotation
            obj.SetAbortFlag(1)
        elif self.painting_mode and self.parent:
            # In paint mode but not actively painting - update cursor position only
            x, y = self.GetInteractor().GetEventPosition()
            if hasattr(self.parent, 'viewer') and self.parent.viewer:
                self.parent.viewer.update_brush_cursor_position(x, y)
            # Abort event to prevent rotation while in paint mode
            obj.SetAbortFlag(1)
        else:
            # Normal rotation mode
            self.OnMouseMove()

    def paint_at_cursor(self):
        """Paint surfaces at cursor location"""
        if not self.parent or not hasattr(self.parent, 'on_paint_at_cursor'):
            return

        # Get mouse position
        x, y = self.GetInteractor().GetEventPosition()

        # Pass to parent for handling
        self.parent.on_paint_at_cursor(x, y)

# Add project root to Python path for imports
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))


class WorkerSignals(QObject):
    """Signals for mesh worker thread"""
    log = pyqtSignal(str)
    progress = pyqtSignal(str, int)  # (phase, percentage) - simplified
    phase_complete = pyqtSignal(str)  # Signal when phase is 100% done
    finished = pyqtSignal(bool, dict)


class MeshWorker:
    """Subprocess mesh generation worker"""

    def __init__(self):
        self.signals = WorkerSignals()
        self.thread = None
        self.process = None
        self.is_running = False
        self.phase_max = {}  # Track max value reached for each phase

    def start(self, cad_file: str, quality_params: dict = None):
        if self.is_running:
            return

        self.is_running = True
        self.phase_max = {}
        self.thread = threading.Thread(target=self._run, args=(cad_file, quality_params), daemon=True)
        self.thread.start()

    def _emit_progress(self, phase: str, value: int):
        """Emit progress only if it's higher than before (prevent jitter)"""
        if phase not in self.phase_max:
            self.phase_max[phase] = 0

        if value > self.phase_max[phase]:
            self.phase_max[phase] = value
            self.signals.progress.emit(phase, value)

    def _complete_phase(self, phase: str):
        """Mark phase as 100% complete"""
        self.phase_max[phase] = 100
        self.signals.progress.emit(phase, 100)
        self.signals.phase_complete.emit(phase)

    def _run(self, cad_file: str, quality_params: dict = None):
        try:
            from multiprocessing import cpu_count

            self.signals.log.emit(f"Loading: {Path(cad_file).name}")
            self._emit_progress("strategy", 5)

            # Show parallel execution info
            cores = cpu_count()
            workers = max(1, cores - 2)
            self.signals.log.emit("=" * 70)
            self.signals.log.emit("PARALLEL EXECUTION MODE ENABLED")
            self.signals.log.emit(f"System: {cores} CPU cores detected")
            self.signals.log.emit(f"Using: {workers} parallel workers (strategies run concurrently)")
            self.signals.log.emit(f"Expected speedup: 3-5x faster than sequential mode")
            self.signals.log.emit("=" * 70)

            # Path to mesh worker (now in apps/cli/)
            worker_script = Path(__file__).parent.parent / "cli" / "mesh_worker_subprocess.py"
            if not worker_script.exists():
                # Fallback: check if mesh_worker.py exists instead
                worker_script = Path(__file__).parent.parent / "cli" / "mesh_worker.py"
            self.signals.log.emit("Starting parallel mesh generation...")

            # Prepare command with quality parameters
            cmd = [sys.executable, str(worker_script), cad_file]
            if quality_params:
                cmd.extend(["--quality-params", json.dumps(quality_params)])

            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1
            )

            for line in self.process.stdout:
                line = line.strip()
                if not line:
                    continue

                # Parse gmsh Info lines
                if "Info" in line:
                    # 1D Meshing
                    if "Meshing 1D" in line:
                        self._emit_progress("1d", 10)
                    elif "Meshing curve" in line and "order 2" not in line:
                        match = re.search(r'\[\s*(\d+)%\]', line)
                        if match:
                            pct = int(match.group(1))
                            self._emit_progress("1d", 10 + int(pct * 0.9))
                    elif "Done meshing 1D" in line:
                        self._complete_phase("1d")

                    # 2D Meshing
                    elif "Meshing 2D" in line:
                        self._emit_progress("2d", 10)
                    elif "Meshing surface" in line and "order 2" not in line:
                        match = re.search(r'\[\s*(\d+)%\]', line)
                        if match:
                            pct = int(match.group(1))
                            self._emit_progress("2d", 10 + int(pct * 0.9))
                    elif "Done meshing 2D" in line:
                        self._complete_phase("2d")

                    # 3D Meshing
                    elif "Meshing 3D" in line:
                        self._emit_progress("3d", 10)
                    elif "Tetrahedrizing" in line:
                        self._emit_progress("3d", 30)
                    elif "Reconstructing mesh" in line:
                        self._emit_progress("3d", 50)
                    elif "3D refinement" in line:
                        self._emit_progress("3d", 70)
                    elif "Done meshing 3D" in line:
                        self._complete_phase("3d")

                    # Optimization (Gmsh)
                    elif "Optimizing mesh..." in line and "Netgen" not in line:
                        self._emit_progress("opt", 10)
                    elif "edge swaps" in line:
                        self._emit_progress("opt", 60)
                    elif "No ill-shaped tets" in line:
                        self._emit_progress("opt", 90)
                    elif "Done optimizing mesh" in line and "Netgen" not in line:
                        self._complete_phase("opt")

                    # Optimization (Netgen)
                    elif "Optimizing mesh (Netgen)" in line:
                        self._emit_progress("netgen", 10)
                    elif "SplitImprove" in line:
                        self._emit_progress("netgen", min(self.phase_max.get("netgen", 10) + 10, 80))
                    elif "SwapImprove" in line:
                        self._emit_progress("netgen", min(self.phase_max.get("netgen", 10) + 5, 85))
                    elif "CombineImprove" in line:
                        self._emit_progress("netgen", min(self.phase_max.get("netgen", 10) + 5, 90))
                    elif "Done optimizing mesh (Wall" in line:
                        self._complete_phase("netgen")

                    # Higher order
                    elif "Meshing order 2" in line:
                        self._emit_progress("order2", 10)
                    elif "order 2" in line:
                        match = re.search(r'\[\s*(\d+)%\]', line)
                        if match:
                            pct = int(match.group(1))
                            self._emit_progress("order2", 10 + int(pct * 0.9))
                    elif "Done meshing order 2" in line:
                        self._complete_phase("order2")

                # Strategy attempts
                if "ATTEMPT" in line:
                    match = re.search(r'ATTEMPT\s+(\d+)/(\d+)', line)
                    if match:
                        current = int(match.group(1))
                        total = int(match.group(2))
                        pct = int((current / total) * 100)
                        self._emit_progress("strategy", pct)

                # Quality analysis
                if "Analyzing mesh quality" in line:
                    self._emit_progress("quality", 50)
                elif "Quality Score" in line:
                    self._emit_progress("quality", 90)

                # Final result
                if line.startswith('{') and '"success"' in line:
                    print(f"[GUI-WORKER] Found JSON result line: {line[:100]}...")
                    try:
                        result = json.loads(line)
                        print(f"[GUI-WORKER] Parsed result, success={result.get('success')}")
                        if result.get('success'):
                            # Mark all active phases as complete
                            for phase in ["strategy", "1d", "2d", "3d", "opt", "netgen", "order2", "quality"]:
                                if self.phase_max.get(phase, 0) > 0:
                                    self._complete_phase(phase)

                            self.signals.log.emit("Mesh generation completed!")
                            self.signals.log.emit(f"[DEBUG] About to emit finished signal with {len(result)} result keys")
                            self.signals.log.emit(f"[DEBUG] Result keys: {list(result.keys())}")
                            self.signals.log.emit(f"[DEBUG] per_element_quality present: {'per_element_quality' in result}")
                            print(f"[GUI-WORKER] Emitting finished signal with result keys: {list(result.keys())}")
                            self.signals.finished.emit(True, result)
                            self.signals.log.emit("[DEBUG] Finished signal emitted!")
                        else:
                            self.signals.log.emit(f"Failed: {result.get('error')}")
                            self.signals.finished.emit(False, result)
                    except Exception as e:
                        print(f"[GUI-WORKER] Failed to parse JSON: {e}")
                        pass
                else:
                    # Debug: Show lines that look like they might be JSON
                    if line.startswith('{') or ('"success"' in line and not line.startswith('Info')):
                        print(f"[GUI-WORKER] Potential JSON line (didn't match): {line[:100]}")
                    self.signals.log.emit(line)

            self.process.wait()

        except Exception as e:
            self.signals.log.emit(f"Exception: {str(e)}")
            self.signals.finished.emit(False, {"error": str(e)})
        finally:
            self.is_running = False


class VTK3DViewer(QFrame):
    """3D viewer with quality report overlay"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameStyle(QFrame.Box | QFrame.Sunken)
        self.setLineWidth(1)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self.vtk_widget = QVTKRenderWindowInteractor(self)
        layout.addWidget(self.vtk_widget)

        self.renderer = vtk.vtkRenderer()
        self.renderer.SetBackground(0.95, 0.95, 0.97)
        self.vtk_widget.GetRenderWindow().AddRenderer(self.renderer)

        # Add ambient lighting to prevent pitch-black shadows
        # This ensures all areas have a minimum illumination level
        self.renderer.SetAmbient(0.4, 0.4, 0.4)  # Soft ambient light

        # Add lights to enhance 3D appearance and show mesh facets clearly
        # Key light (main light from upper front-right)
        light1 = vtk.vtkLight()
        light1.SetPosition(1, 1, 1)
        light1.SetFocalPoint(0, 0, 0)
        light1.SetColor(1.0, 1.0, 1.0)
        light1.SetIntensity(0.6)  # Reduced from 0.8 to balance with ambient
        self.renderer.AddLight(light1)

        # Fill light (softer light from upper left to fill shadows)
        light2 = vtk.vtkLight()
        light2.SetPosition(-0.5, 1, 0.5)
        light2.SetFocalPoint(0, 0, 0)
        light2.SetColor(1.0, 1.0, 1.0)
        light2.SetIntensity(0.3)  # Reduced from 0.4 to balance with ambient
        self.renderer.AddLight(light2)

        # Back light (subtle rim light to show edges)
        light3 = vtk.vtkLight()
        light3.SetPosition(0, 0.5, -1)
        light3.SetFocalPoint(0, 0, 0)
        light3.SetColor(1.0, 1.0, 1.0)
        light3.SetIntensity(0.2)  # Reduced from 0.3 to balance with ambient
        self.renderer.AddLight(light3)

        # Use custom interactor style with right-click pan and paintbrush support
        self.interactor_style = CustomInteractorStyle(parent=parent)
        self.vtk_widget.GetRenderWindow().GetInteractor().SetInteractorStyle(self.interactor_style)

        # Orientation marker
        self.axes_widget = vtk.vtkOrientationMarkerWidget()
        self.axes_actor = vtk.vtkAxesActor()
        self.axes_actor.SetShaftTypeToCylinder()
        self.axes_actor.SetTotalLength(1.0, 1.0, 1.0)
        self.axes_actor.SetCylinderRadius(0.02)
        self.axes_actor.GetXAxisCaptionActor2D().GetCaptionTextProperty().SetFontSize(12)
        self.axes_actor.GetYAxisCaptionActor2D().GetCaptionTextProperty().SetFontSize(12)
        self.axes_actor.GetZAxisCaptionActor2D().GetCaptionTextProperty().SetFontSize(12)
        self.axes_widget.SetOrientationMarker(self.axes_actor)
        self.axes_widget.SetInteractor(self.vtk_widget.GetRenderWindow().GetInteractor())
        self.axes_widget.SetViewport(0, 0, 0.15, 0.15)
        self.axes_widget.SetEnabled(1)
        self.axes_widget.InteractiveOff()

        self.current_actor = None
        self.current_poly_data = None  # Store unclipped mesh data
        self.clipping_enabled = False
        self.clip_plane = None
        self.clip_axis = 'x'
        self.clip_offset = 0.0  # -50 to +50 percentage

        # Paintbrush visual feedback
        self.brush_cursor_actor = None
        self.brush_cursor_visible = False
        self.paint_markers = []  # List of sphere actors showing painted locations

        self.vtk_widget.Initialize()
        self.vtk_widget.Start()

        # Info overlay (top-left) - FIXED WIDTH to prevent truncation
        self.info_label = QLabel("No CAD file loaded", self)
        self.info_label.setStyleSheet("""
            QLabel {
                background-color: rgba(255, 255, 255, 230);
                padding: 12px 16px;
                border-radius: 6px;
                font-size: 11px;
                color: #212529;
                font-weight: 500;
                border: 1px solid rgba(0,0,0,0.1);
            }
        """)
        self.info_label.setFixedWidth(450)  # Increased from 400 to 450
        self.info_label.setMinimumHeight(80)  # Minimum height to prevent vertical truncation
        self.info_label.setMaximumHeight(300)  # Increased from 200 to 300px for iterations
        self.info_label.setWordWrap(True)
        self.info_label.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        self.info_label.move(15, 15)

        # Quality report overlay (top-right) - initially hidden
        self.quality_label = QLabel("", self)
        self.quality_label.setTextFormat(Qt.RichText)  # Enable HTML rendering
        self.quality_label.setTextInteractionFlags(Qt.TextSelectableByMouse)  # Allow selection
        self.quality_label.setStyleSheet("""
            QLabel {
                background-color: rgba(255, 255, 255, 230);
                padding: 12px 16px;
                border-radius: 6px;
                font-size: 11px;
                color: #212529;
                border: 1px solid rgba(0,0,0,0.1);
            }
        """)
        self.quality_label.setMinimumWidth(250)
        self.quality_label.setMaximumWidth(300)
        self.quality_label.setWordWrap(True)
        self.quality_label.setVisible(False)

        # Iteration selector buttons (bottom-right)
        self.iteration_buttons = []
        self.iteration_meshes = []  # Store mesh file paths for each iteration
        self.current_iteration = 0

        self.iteration_container = QFrame(self)
        self.iteration_container.setStyleSheet("""
            QFrame {
                background-color: rgba(255, 255, 255, 230);
                border-radius: 6px;
                border: 1px solid rgba(0,0,0,0.1);
                padding: 5px;
            }
        """)
        iteration_layout = QHBoxLayout(self.iteration_container)
        iteration_layout.setContentsMargins(5, 5, 5, 5)
        iteration_layout.setSpacing(5)

        # Create buttons for iterations 1-5
        for i in range(1, 6):
            btn = QPushButton(str(i))
            btn.setFixedSize(30, 30)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #e9ecef;
                    border: 1px solid #adb5bd;
                    border-radius: 4px;
                    font-size: 12px;
                    font-weight: bold;
                    color: #495057;
                }
                QPushButton:hover {
                    background-color: #dee2e6;
                    border-color: #6c757d;
                }
                QPushButton:disabled {
                    background-color: #f8f9fa;
                    color: #ced4da;
                    border-color: #dee2e6;
                }
                QPushButton[selected="true"] {
                    background-color: #0d6efd;
                    color: white;
                    border-color: #0d6efd;
                }
            """)
            btn.setEnabled(False)  # Disabled until iteration exists
            btn.clicked.connect(lambda checked, idx=i-1: self.switch_to_iteration(idx))
            iteration_layout.addWidget(btn)
            self.iteration_buttons.append(btn)

        self.iteration_container.setVisible(False)  # Hidden until we have iterations

    def resizeEvent(self, event):
        """Reposition quality label and iteration buttons on resize"""
        super().resizeEvent(event)
        if self.quality_label.isVisible():
            self.quality_label.move(
                self.width() - self.quality_label.width() - 15,
                15
            )

        # Position iteration container in bottom-right corner
        if self.iteration_container.isVisible():
            self.iteration_container.adjustSize()
            self.iteration_container.move(
                self.width() - self.iteration_container.width() - 15,
                self.height() - self.iteration_container.height() - 15
            )

    def toggle_axes(self, visible: bool):
        self.axes_widget.SetEnabled(1 if visible else 0)
        self.vtk_widget.GetRenderWindow().Render()

    def clear_view(self):
        if self.current_actor:
            self.renderer.RemoveActor(self.current_actor)
            self.current_actor = None
        self.renderer.ResetCamera()
        self.vtk_widget.GetRenderWindow().Render()

    def show_quality_report(self, metrics: Dict):
        """Show quality metrics overlay in top-right"""
        # Extract from nested structure (gmsh_sicn: {min, avg, max})
        sicn_min = None
        if 'gmsh_sicn' in metrics and isinstance(metrics['gmsh_sicn'], dict):
            sicn_min = metrics['gmsh_sicn'].get('min')
        elif 'sicn_min' in metrics:
            sicn_min = metrics['sicn_min']

        gamma_min = None
        if 'gmsh_gamma' in metrics and isinstance(metrics['gmsh_gamma'], dict):
            gamma_min = metrics['gmsh_gamma'].get('min')
        elif 'gamma_min' in metrics:
            gamma_min = metrics['gamma_min']

        max_skew = None
        if 'skewness' in metrics and isinstance(metrics['skewness'], dict):
            max_skew = metrics['skewness'].get('max')
        elif 'max_skewness' in metrics:
            max_skew = metrics['max_skewness']

        max_ar = None
        if 'aspect_ratio' in metrics and isinstance(metrics['aspect_ratio'], dict):
            max_ar = metrics['aspect_ratio'].get('max')
        elif 'max_aspect_ratio' in metrics:
            max_ar = metrics['max_aspect_ratio']

        # Extract badness (element quality measure from Netgen)
        badness = None
        if 'badness' in metrics and isinstance(metrics['badness'], dict):
            badness = metrics['badness'].get('max')
        elif 'max_badness' in metrics:
            badness = metrics['max_badness']

        # Extract worst tet radius ratio
        worst_tet_radius = None
        if 'tet_radius_ratio' in metrics and isinstance(metrics['tet_radius_ratio'], dict):
            worst_tet_radius = metrics['tet_radius_ratio'].get('min')
        elif 'worst_tet_radius_ratio' in metrics:
            worst_tet_radius = metrics['worst_tet_radius_ratio']

        # Get geometric accuracy (most important for shape fidelity)
        geom_accuracy = metrics.get('geometric_accuracy')
        mean_dev = metrics.get('mean_deviation_mm')

        # Determine grade based on geometric accuracy (prioritized)
        grade = "Excellent"
        grade_color = "#198754"
        if geom_accuracy is not None:
            # Use geometric accuracy as primary metric
            if geom_accuracy >= 0.95:
                grade = "Excellent"
                grade_color = "#198754"
            elif geom_accuracy >= 0.85:
                grade = "Good"
                grade_color = "#0d6efd"
            elif geom_accuracy >= 0.75:
                grade = "Fair"
                grade_color = "#ffc107"
            elif geom_accuracy >= 0.60:
                grade = "Poor"
                grade_color = "#fd7e14"
            else:
                grade = "Critical"
                grade_color = "#dc3545"
        elif sicn_min is not None:
            # Fallback to SICN if no geometric accuracy
            if sicn_min < 0.0001:
                grade = "Critical"
                grade_color = "#dc3545"
            elif sicn_min < 0.1:
                grade = "Very Poor"
                grade_color = "#dc3545"
            elif sicn_min < 0.3:
                grade = "Poor"
                grade_color = "#fd7e14"
            elif sicn_min < 0.5:
                grade = "Fair"
                grade_color = "#ffc107"
            elif sicn_min < 0.7:
                grade = "Good"
                grade_color = "#0d6efd"

        report_html = f"""
        <div style='font-family: Arial; font-size: 11px;'>
            <div style='font-size: 13px; font-weight: bold; margin-bottom: 8px; color: {grade_color};'>
                Quality: {grade}
            </div>
        """

        # Show geometric accuracy FIRST (most important)
        if geom_accuracy is not None:
            icon = "[OK]" if geom_accuracy >= 0.85 else "[X]"
            color = "#198754" if geom_accuracy >= 0.85 else "#dc3545"
            report_html += f"<div><b>Shape Accuracy:</b> {geom_accuracy:.3f} <span style='color: {color};'>{icon}</span></div>"
            if mean_dev is not None:
                report_html += f"<div style='font-size: 10px; color: #6c757d;'>   (deviation: {mean_dev:.3f}mm)</div>"

        if sicn_min is not None:
            icon = "[OK]" if sicn_min >= 0.3 else "[X]"
            color = "#198754" if sicn_min >= 0.3 else "#dc3545"
            report_html += f"<div><b>SICN (min):</b> {sicn_min:.4f} <span style='color: {color};'>{icon}</span></div>"

        if gamma_min is not None:
            icon = "[OK]" if gamma_min >= 0.2 else "[X]"
            color = "#198754" if gamma_min >= 0.2 else "#dc3545"
            report_html += f"<div><b>Gamma (min):</b> {gamma_min:.4f} <span style='color: {color};'>{icon}</span></div>"

        if max_skew is not None:
            icon = "[OK]" if max_skew <= 0.7 else "[X]"
            color = "#198754" if max_skew <= 0.7 else "#dc3545"
            report_html += f"<div><b>Max Skewness:</b> {max_skew:.4f} <span style='color: {color};'>{icon}</span></div>"

        if max_ar is not None:
            icon = "[OK]" if max_ar <= 5.0 else "[X]"
            color = "#198754" if max_ar <= 5.0 else "#dc3545"
            report_html += f"<div><b>Max Aspect Ratio:</b> {max_ar:.2f} <span style='color: {color};'>{icon}</span></div>"

        if badness is not None:
            # Badness: lower is better. <10 is good, >100 is bad
            icon = "[OK]" if badness <= 10 else "[X]"
            color = "#198754" if badness <= 10 else "#dc3545"
            report_html += f"<div><b>Badness (max):</b> {badness:.2f} <span style='color: {color};'>{icon}</span></div>"

        if worst_tet_radius is not None:
            # Tet radius ratio: closer to 1.0 is better (perfect tetrahedron)
            icon = "[OK]" if worst_tet_radius >= 0.5 else "[X]"
            color = "#198754" if worst_tet_radius >= 0.5 else "#dc3545"
            report_html += f"<div><b>Worst Tet Radius:</b> {worst_tet_radius:.4f} <span style='color: {color};'>{icon}</span></div>"

        report_html += "</div>"

        self.quality_label.setText(report_html)
        self.quality_label.adjustSize()
        self.quality_label.move(
            self.width() - self.quality_label.width() - 15,
            15
        )
        self.quality_label.setVisible(True)

    def add_iteration_mesh(self, mesh_path: str, metrics: Dict = None):
        """Add a new iteration mesh and display it"""
        logging.info(f"add_iteration_mesh called: {mesh_path}")

        if len(self.iteration_meshes) >= 5:
            logging.warning("Maximum 5 iterations reached, not adding more")
            return

        # Store the mesh path
        self.iteration_meshes.append({
            'path': mesh_path,
            'metrics': metrics
        })

        iteration_idx = len(self.iteration_meshes) - 1
        logging.info(f"Added iteration {iteration_idx + 1} at path: {mesh_path}")

        # Enable the corresponding button
        self.iteration_buttons[iteration_idx].setEnabled(True)

        # Show the iteration container if this is the first iteration
        if len(self.iteration_meshes) == 1:
            self.iteration_container.setVisible(True)
            self.iteration_container.adjustSize()
            self.iteration_container.move(
                self.width() - self.iteration_container.width() - 15,
                self.height() - self.iteration_container.height() - 15
            )

        # Auto-switch to the new iteration
        self.switch_to_iteration(iteration_idx)

    def switch_to_iteration(self, iteration_idx: int):
        """Switch to display a specific iteration's mesh"""
        logging.info(f"switch_to_iteration called: {iteration_idx}")

        if iteration_idx < 0 or iteration_idx >= len(self.iteration_meshes):
            logging.warning(f"Invalid iteration index: {iteration_idx}")
            return

        self.current_iteration = iteration_idx
        iteration_data = self.iteration_meshes[iteration_idx]

        # Update button styling to show which is selected
        for i, btn in enumerate(self.iteration_buttons):
            if i == iteration_idx:
                btn.setProperty("selected", "true")
            else:
                btn.setProperty("selected", "false")
            btn.style().unpolish(btn)
            btn.style().polish(btn)

        # Load and display the mesh
        mesh_path = iteration_data['path']
        metrics = iteration_data.get('metrics')

        logging.info(f"Loading iteration {iteration_idx + 1}: {mesh_path}")

        if Path(mesh_path).exists():
            self.load_mesh_file(mesh_path, {'quality_metrics': metrics} if metrics else None)

            # Update info label to show iteration number (prepend to existing HTML)
            info_text = self.info_label.text()
            # Insert iteration text at the beginning, preserving HTML structure
            info_text = f"<b>Iteration {iteration_idx + 1}</b><br>" + info_text
            self.info_label.setText(info_text)

            # Show quality report if we have metrics
            if metrics:
                self.show_quality_report(metrics)
        else:
            logging.error(f"Mesh file not found: {mesh_path}")

    def clear_iterations(self):
        """Clear all iteration data (e.g., when loading a new CAD file)"""
        logging.info("Clearing all iterations")
        self.iteration_meshes = []
        self.current_iteration = 0
        self.iteration_container.setVisible(False)

        for btn in self.iteration_buttons:
            btn.setEnabled(False)
            btn.setProperty("selected", "false")
            btn.style().unpolish(btn)
            btn.style().polish(btn)

    def set_clipping(self, enabled: bool, axis: str = 'x', offset: float = 0.0):
        """
        Enable/disable cross-section clipping with live updates.
        
        Args:
            enabled: Whether to enable clipping
            axis: 'x', 'y', or 'z'
            offset: Offset from center as percentage (-50 to +50)
        """
        self.clipping_enabled = enabled
        self.clip_axis = axis.lower()
        self.clip_offset = offset
        
        if not self.current_poly_data:
            return
        
        if enabled:
            self._apply_clipping()
        else:
            self._remove_clipping()
    
    def _apply_clipping(self):
        """Apply capped cross-section cut to current mesh"""
        if not self.current_poly_data or not self.current_actor:
            return
        
        bounds = self.current_poly_data.GetBounds()
        center = [
            (bounds[0] + bounds[1]) / 2,
            (bounds[2] + bounds[3]) / 2,
            (bounds[4] + bounds[5]) / 2
        ]
        
        # Determine plane normal and origin based on axis and offset
        if self.clip_axis == 'x':
            normal = (-1, 0, 0)
            dim_size = bounds[1] - bounds[0]
            origin = [center[0] + (dim_size * self.clip_offset / 100.0), center[1], center[2]]
        elif self.clip_axis == 'y':
            normal = (0, -1, 0)
            dim_size = bounds[3] - bounds[2]
            origin = [center[0], center[1] + (dim_size * self.clip_offset / 100.0), center[2]]
        else:  # z
            normal = (0, 0, -1)
            dim_size = bounds[5] - bounds[4]
            origin = [center[0], center[1], center[2] + (dim_size * self.clip_offset / 100.0)]
        
        # Create clipping plane
        plane = vtk.vtkPlane()
        plane.SetNormal(normal)
        plane.SetOrigin(origin)
        
        # Create plane collection
        planes = vtk.vtkPlaneCollection()
        planes.AddItem(plane)
        
        # Use vtkClipClosedSurface for capped cut
        clipper = vtk.vtkClipClosedSurface()
        clipper.SetInputData(self.current_poly_data)
        clipper.SetClippingPlanes(planes)
        clipper.SetActivePlaneId(0)
        clipper.SetScalarModeToColors()
        clipper.SetClipColor(0.9, 0.4, 0.4)  # Reddish cap
        clipper.SetBaseColor(0.7, 0.85, 0.95)  # Light blue mesh
        clipper.SetActivePlaneColor(0.9, 0.4, 0.4)
        clipper.GenerateFacesOn()
        clipper.Update()
        
        # Update actor with clipped mesh
        mapper = self.current_actor.GetMapper()
        mapper.SetInputData(clipper.GetOutput())
        
        self.vtk_widget.GetRenderWindow().Render()
    
    def _remove_clipping(self):
        """Remove clipping and restore original mesh"""
        if not self.current_poly_data or not self.current_actor:
            return
        
        # Restore original unclipped data
        mapper = self.current_actor.GetMapper()
        mapper.SetInputData(self.current_poly_data)
        
        self.vtk_widget.GetRenderWindow().Render()

    def create_brush_cursor(self, radius: float):
        """Create or update brush cursor sphere"""
        print(f"[DEBUG] Creating brush cursor with radius: {radius}")

        # Remove old cursor if exists
        if self.brush_cursor_actor:
            self.renderer.RemoveActor(self.brush_cursor_actor)

        # Create sphere for brush cursor
        sphere = vtk.vtkSphereSource()
        sphere.SetRadius(radius)
        sphere.SetThetaResolution(20)
        sphere.SetPhiResolution(20)

        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputConnection(sphere.GetOutputPort())

        self.brush_cursor_actor = vtk.vtkActor()
        self.brush_cursor_actor.SetMapper(mapper)
        # Bright cyan color for better visibility
        self.brush_cursor_actor.GetProperty().SetColor(0.0, 1.0, 1.0)  # Cyan
        self.brush_cursor_actor.GetProperty().SetOpacity(0.5)
        self.brush_cursor_actor.GetProperty().SetRepresentationToWireframe()
        self.brush_cursor_actor.GetProperty().SetLineWidth(3)
        # Render as tubes for better visibility
        self.brush_cursor_actor.GetProperty().SetRenderLinesAsTubes(True)

        # Initially hidden
        self.brush_cursor_actor.VisibilityOff()
        self.renderer.AddActor(self.brush_cursor_actor)
        self.brush_cursor_visible = False
        print(f"[DEBUG] Brush cursor actor created and added to renderer")

    def update_brush_cursor_position(self, x: int, y: int):
        """Update brush cursor position to follow mouse"""
        if not self.brush_cursor_actor:
            print("[DEBUG] No brush cursor actor to update")
            return

        # Use cell picker to pick actual surface points
        picker = vtk.vtkCellPicker()
        picker.SetTolerance(0.005)  # Set picking tolerance

        if picker.Pick(x, y, 0, self.renderer):
            # Successfully picked a surface point
            point = picker.GetPickPosition()
            self.brush_cursor_actor.SetPosition(point)

            if not self.brush_cursor_visible:
                print(f"[DEBUG] Showing brush cursor at {point}")
                self.brush_cursor_actor.VisibilityOn()
                self.brush_cursor_visible = True

            self.vtk_widget.GetRenderWindow().Render()
        else:
            # No surface picked - hide cursor
            if self.brush_cursor_visible:
                self.brush_cursor_actor.VisibilityOff()
                self.brush_cursor_visible = False
                self.vtk_widget.GetRenderWindow().Render()

    def show_paint_marker(self, position, radius: float):
        """Add a visual marker at painted location"""
        sphere = vtk.vtkSphereSource()
        sphere.SetCenter(position)
        sphere.SetRadius(radius * 0.5)  # Half size for marker
        sphere.SetThetaResolution(8)
        sphere.SetPhiResolution(8)

        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputConnection(sphere.GetOutputPort())

        actor = vtk.vtkActor()
        actor.SetMapper(mapper)
        actor.GetProperty().SetColor(0.2, 1.0, 0.2)  # Light green
        actor.GetProperty().SetOpacity(0.4)

        self.renderer.AddActor(actor)
        self.paint_markers.append(actor)
        self.vtk_widget.GetRenderWindow().Render()

    def clear_paint_markers(self):
        """Remove all paint markers"""
        for actor in self.paint_markers:
            self.renderer.RemoveActor(actor)
        self.paint_markers.clear()
        self.vtk_widget.GetRenderWindow().Render()

    def load_step_file(self, filepath: str):
        self.clear_view()
        self.quality_label.setVisible(False)
        self.info_label.setText(f"Loading: {Path(filepath).name}")

        try:
            import pyvista as pv

            with tempfile.NamedTemporaryFile(suffix='.stl', delete=False) as tmp:
                tmp_stl = tmp.name

            # Tessellate CAD for preview display and extract geometry info
            # This generates a quick surface representation for visualization
            gmsh_script = f"""
import gmsh
import json
gmsh.initialize()
gmsh.option.setNumber("General.Terminal", 0)
try:
    gmsh.open("{filepath}")

    # Get bounding box
    bbox = gmsh.model.getBoundingBox(-1, -1)
    bbox_dims = [bbox[3]-bbox[0], bbox[4]-bbox[1], bbox[5]-bbox[2]]

    # Get volume using OCC's built-in method
    volumes_3d = gmsh.model.getEntities(dim=3)
    total_volume_raw = 0.0
    for vol_dim, vol_tag in volumes_3d:
        vol_mass = gmsh.model.occ.getMass(vol_dim, vol_tag)
        total_volume_raw += vol_mass

    # Calculate bbox volume in same units
    bbox_volume_raw = bbox_dims[0] * bbox_dims[1] * bbox_dims[2]

    # Detect units by comparing raw volume to bbox volume
    # If getMass returns ~300k but bbox is 100×100×50, that's mm³!
    # Cylinder: volume = π×r²×h ≈ 0.785 × bbox_volume
    # Most parts: 0.1 to 0.9 of bbox volume
    # If volume/bbox > 10, units must be smaller (mm vs m)
    if total_volume_raw > 10000:
        # Large numbers suggest mm³ or cm³
        unit_scale = 0.001
        unit_name = "mm"
    elif max(bbox_dims) > 1000:
        # Large bbox suggests mm
        unit_scale = 0.001
        unit_name = "mm"
    else:
        # Small bbox and reasonable volume → meters
        unit_scale = 1.0
        unit_name = "m"

    # Apply scaling
    total_volume = total_volume_raw * (unit_scale ** 3)
    bbox_volume = bbox_volume_raw * (unit_scale ** 3)
    bbox_diag = (bbox_dims[0]**2 + bbox_dims[1]**2 + bbox_dims[2]**2)**0.5 * unit_scale

    # Sanity check: volume should be less than bbox
    if total_volume > bbox_volume or total_volume <= 0:
        total_volume = bbox_volume * 0.4

    # Print geometry info as JSON
    geom_info = {{"volume": total_volume, "bbox_diagonal": bbox_diag, "bbox_volume": bbox_volume, "units_detected": unit_name}}
    print("GEOM_INFO:" + json.dumps(geom_info))

    # Quick tessellation for fast CAD preview (no 3D meshing!)
    gmsh.model.mesh.generate(2)
    gmsh.write("{tmp_stl}")
    gmsh.finalize()
    print("SUCCESS")
except Exception as e:
    print("ERROR:" + str(e))
    gmsh.finalize()
"""

            result = subprocess.run(
                [sys.executable, "-c", gmsh_script],
                capture_output=True,
                text=True,
                timeout=30
            )

            if "SUCCESS" not in result.stdout:
                raise Exception("Conversion failed")

            # Parse geometry info from output
            geom_info = None
            for line in result.stdout.split('\n'):
                if line.startswith("GEOM_INFO:"):
                    geom_info = json.loads(line[10:])
                    break

            mesh = pv.read(tmp_stl)
            os.unlink(tmp_stl)

            # ============================================================
            # COMPREHENSIVE VTK DEBUG DIAGNOSTICS
            # ============================================================
            print(f"\n{'='*70}")
            print(f"[VTK DEBUG] CAD Visualization Diagnostics")
            print(f"{'='*70}")
            print(f"File: {Path(filepath).name}")

            # 1. Check PyVista mesh
            print(f"\n[1] PyVista Mesh:")
            print(f"    Points: {mesh.n_points}")
            print(f"    Cells: {mesh.n_cells}")
            print(f"    Bounds: {mesh.bounds}")  # (xmin, xmax, ymin, ymax, zmin, zmax)
            print(f"    Center: {mesh.center}")

            # Check for empty mesh
            if mesh.n_points == 0 or mesh.n_cells == 0:
                print(f"    ⚠ WARNING: Mesh is empty!")
                print(f"    This means the STEP file had no geometry to tessellate.")
                raise Exception("Empty mesh - no geometry in CAD file")

            poly_data = mesh.cast_to_unstructured_grid().extract_surface()

            # Store for cross-section clipping
            self.current_poly_data = poly_data

            # 2. Check VTK PolyData
            print(f"\n[2] VTK PolyData:")
            print(f"    Points: {poly_data.GetNumberOfPoints()}")
            print(f"    Cells: {poly_data.GetNumberOfCells()}")
            poly_bounds = poly_data.GetBounds()
            print(f"    Bounds: ({poly_bounds[0]:.3f}, {poly_bounds[1]:.3f}, "
                  f"{poly_bounds[2]:.3f}, {poly_bounds[3]:.3f}, "
                  f"{poly_bounds[4]:.3f}, {poly_bounds[5]:.3f})")

            # Calculate bounding box size
            bbox_size = [
                poly_bounds[1] - poly_bounds[0],  # x
                poly_bounds[3] - poly_bounds[2],  # y
                poly_bounds[5] - poly_bounds[4]   # z
            ]
            bbox_diagonal = (bbox_size[0]**2 + bbox_size[1]**2 + bbox_size[2]**2)**0.5
            print(f"    Bounding box size: ({bbox_size[0]:.3f}, {bbox_size[1]:.3f}, {bbox_size[2]:.3f})")
            print(f"    Bounding box diagonal: {bbox_diagonal:.3f}")

            # Check for degenerate geometry
            if bbox_diagonal < 0.001:
                print(f"    ⚠ WARNING: Geometry is extremely small (diagonal < 0.001)")
                print(f"    The model might be invisible due to scale.")
            elif bbox_diagonal > 100000:
                print(f"    ⚠ WARNING: Geometry is extremely large (diagonal > 100000)")
                print(f"    The model might be outside camera view.")

            mapper = vtk.vtkPolyDataMapper()
            mapper.SetInputData(poly_data)

            self.current_actor = vtk.vtkActor()
            self.current_actor.SetMapper(mapper)

            # 3. Check Mapper
            print(f"\n[3] VTK Mapper:")
            print(f"    Input connection: {mapper.GetNumberOfInputConnections(0)}")
            print(f"    Static: {mapper.GetStatic()}")
            print(f"    Scalar visibility: {mapper.GetScalarVisibility()}")

            # Render CAD as SMOOTH SURFACE (no visible facets)
            self.current_actor.GetProperty().SetColor(0.3, 0.5, 0.8)  # Blue for CAD
            self.current_actor.GetProperty().SetOpacity(1.0)

            # Use Phong shading for smooth appearance
            self.current_actor.GetProperty().SetInterpolationToPhong()

            # HIDE edges to make it look smooth like CAD
            self.current_actor.GetProperty().EdgeVisibilityOff()

            # Set material properties for better visibility
            self.current_actor.GetProperty().SetAmbient(0.4)  # Reflects ambient light
            self.current_actor.GetProperty().SetDiffuse(0.7)  # Main surface color
            self.current_actor.GetProperty().SetSpecular(0.3)  # Moderate specular for glossy look
            self.current_actor.GetProperty().SetSpecularPower(30)  # Moderate glossiness

            # 4. Check Actor Properties
            print(f"\n[4] VTK Actor:")
            print(f"    Visibility: {self.current_actor.GetVisibility()}")
            print(f"    Pickable: {self.current_actor.GetPickable()}")
            print(f"    Color: {self.current_actor.GetProperty().GetColor()}")
            print(f"    Opacity: {self.current_actor.GetProperty().GetOpacity()}")
            print(f"    Edge visibility: {self.current_actor.GetProperty().GetEdgeVisibility()}")

            # 5. Check Renderer State BEFORE adding actor
            print(f"\n[5] Renderer State (before adding actor):")
            print(f"    Actors: {self.renderer.GetNumberOfPropsRendered()}")
            print(f"    Lights: {self.renderer.GetLights().GetNumberOfItems()}")
            active_camera_before = self.renderer.GetActiveCamera()
            if active_camera_before:
                print(f"    Camera position: {active_camera_before.GetPosition()}")
                print(f"    Camera focal point: {active_camera_before.GetFocalPoint()}")
                print(f"    Camera view up: {active_camera_before.GetViewUp()}")
                clip_range = active_camera_before.GetClippingRange()
                print(f"    Camera clipping range: ({clip_range[0]:.3f}, {clip_range[1]:.3f})")

            self.renderer.AddActor(self.current_actor)

            # 6. Check Renderer State AFTER adding actor
            print(f"\n[6] Renderer State (after adding actor):")
            print(f"    Actors: {self.renderer.GetActors().GetNumberOfItems()}")
            print(f"    Props rendered: {self.renderer.GetNumberOfPropsRendered()}")

            # 7. Reset Camera and check new camera state
            print(f"\n[7] Camera Reset:")
            self.renderer.ResetCamera()
            active_camera = self.renderer.GetActiveCamera()
            if active_camera:
                pos = active_camera.GetPosition()
                focal = active_camera.GetFocalPoint()
                view_up = active_camera.GetViewUp()
                clip_range = active_camera.GetClippingRange()
                distance = active_camera.GetDistance()

                print(f"    Camera position: ({pos[0]:.3f}, {pos[1]:.3f}, {pos[2]:.3f})")
                print(f"    Camera focal point: ({focal[0]:.3f}, {focal[1]:.3f}, {focal[2]:.3f})")
                print(f"    Camera distance: {distance:.3f}")
                print(f"    Camera view up: ({view_up[0]:.3f}, {view_up[1]:.3f}, {view_up[2]:.3f})")
                print(f"    Camera clipping range: ({clip_range[0]:.3f}, {clip_range[1]:.3f})")

                # Check if clipping range is reasonable for geometry
                if bbox_diagonal > clip_range[1]:
                    print(f"    ⚠ WARNING: Geometry diagonal ({bbox_diagonal:.3f}) > far clip plane ({clip_range[1]:.3f})")
                    print(f"    The model might be clipped by the camera!")
                    # Fix clipping range
                    active_camera.SetClippingRange(0.01 * bbox_diagonal, 100 * bbox_diagonal)
                    print(f"    Adjusted clipping range to: (0.01*diagonal, 100*diagonal)")
            else:
                print(f"    ⚠ WARNING: No active camera!")

            # 8. Check Render Window
            print(f"\n[8] Render Window:")
            render_window = self.vtk_widget.GetRenderWindow()
            if render_window:
                size = render_window.GetSize()
                print(f"    Size: {size[0]} x {size[1]}")
                print(f"    Number of renderers: {render_window.GetRenderers().GetNumberOfItems()}")
                print(f"    Never rendered: {render_window.GetNeverRendered()}")
            else:
                print(f"    ⚠ WARNING: No render window!")

            # 9. Force render
            print(f"\n[9] Forcing Render:")
            self.vtk_widget.GetRenderWindow().Render()
            print(f"    Render() called")

            # Update interactor
            if hasattr(self.vtk_widget, 'GetInteractor'):
                interactor = self.vtk_widget.GetInteractor()
                if interactor:
                    print(f"    Interactor present")
                    if not interactor.GetInitialized():
                        print(f"    ⚠ Interactor not initialized - calling Initialize()")
                        interactor.Initialize()
                else:
                    print(f"    ⚠ WARNING: No interactor!")

            print(f"\n{'='*70}")
            print(f"[VTK DEBUG] Diagnostics Complete")
            print(f"{'='*70}\n")

            # If we got here, everything should be visible
            # If the user still can't see it, check the debug output above

            num_points = poly_data.GetNumberOfPoints()
            num_cells = poly_data.GetNumberOfCells()

            # Include volume in info label if available
            volume_text = ""
            if geom_info and 'volume' in geom_info:
                volume = geom_info['volume']
                if volume > 0.001:
                    volume_text = f"<br>Volume: {volume:.4f} m³"
                elif volume > 0.000001:
                    volume_text = f"<br>Volume: {volume*1e6:.2f} cm³"
                else:
                    volume_text = f"<br>Volume: {volume*1e9:.2f} mm³"

            self.info_label.setText(
                f"<b>CAD File</b><br>"
                f"{Path(filepath).name}<br>"
                f"<span style='color: #6c757d;'>{num_points:,} points • {num_cells:,} faces{volume_text}</span>"
            )

            return geom_info

        except Exception as e:
            self.info_label.setText(f"CAD: {Path(filepath).name}<br><small>Click 'Generate Mesh'</small>")
            return None

    def load_mesh_file(self, filepath: str, result: dict = None):
        """Load and display mesh file with optional result dict for counts"""
        print(f"\n{'='*70}")
        print(f"[DEBUG] load_mesh_file called:")
        print(f"  filepath: {filepath}")
        print(f"  File exists: {Path(filepath).exists()}")
        if result:
            print(f"  result keys: {list(result.keys())}")
            if 'per_element_quality' in result:
                print(f"  [OK][OK]per_element_quality present: {len(result['per_element_quality'])} elements")
            else:
                print(f"  [X][X]per_element_quality NOT in result dict!")
            if 'quality_metrics' in result:
                print(f"  [OK][OK]quality_metrics present: {result['quality_metrics']}")
            else:
                print(f"  [X][X]quality_metrics NOT in result dict!")
        else:
            print(f"  [X][X]result dict is None!")
        print(f"{'='*70}")

        self.clear_view()
        self.info_label.setText("Loading mesh...")

        try:
            print(f"[DEBUG] Parsing .msh file...")
            nodes, elements = self._parse_msh_file(filepath)
            print(f"[DEBUG] Parsed {len(nodes)} nodes, {len(elements)} elements")

            # Try to load surface quality data if not provided
            if not (result and result.get('per_element_quality')):
                quality_file = Path(filepath).with_suffix('.quality.json')
                print(f"[DEBUG] Checking for quality file: {quality_file}")
                print(f"[DEBUG] Quality file exists: {quality_file.exists()}")
                if quality_file.exists():
                    print(f"[DEBUG] Loading surface quality data from {quality_file}")
                    try:
                        import json
                        with open(quality_file, 'r') as f:
                            surface_quality = json.load(f)

                        if not result:
                            result = {}
                        result['per_element_quality'] = surface_quality.get('per_element_quality', {})
                        result['quality_metrics'] = {
                            'sicn_10_percentile': surface_quality.get('quality_threshold_10', 0.3),
                            'sicn_min': surface_quality.get('statistics', {}).get('min_quality', 0.0),
                            'sicn_avg': surface_quality.get('statistics', {}).get('avg_quality', 0.5),
                            'sicn_max': surface_quality.get('statistics', {}).get('max_quality', 1.0)
                        }
                        print(f"[DEBUG] [OK][OK]Loaded quality data for {len(result['per_element_quality'])} triangles")
                        print(f"[DEBUG] [OK][OK]Quality threshold: {result['quality_metrics']['sicn_10_percentile']:.3f}")
                    except Exception as e:
                        print(f"[DEBUG] [X][X]Could not load quality data: {e}")
                        import traceback
                        traceback.print_exc()
            else:
                print(f"[DEBUG] Quality data already in result dict")

            print(f"[DEBUG] Creating VTK data structures...")
            points = vtk.vtkPoints()
            cells = vtk.vtkCellArray()

            node_map = {}
            for idx, (node_id, coords) in enumerate(nodes.items()):
                points.InsertNextPoint(coords)
                node_map[node_id] = idx

            print(f"[DEBUG] Added {points.GetNumberOfPoints()} points to VTK")

            # Count elements for display
            tet_count = sum(1 for e in elements if e['type'] == 'tetrahedron')
            tri_count = sum(1 for e in elements if e['type'] == 'triangle')

            print(f"[DEBUG] Element counts: {tet_count} tets, {tri_count} triangles")

            # CRITICAL: Only visualize SURFACE TRIANGLES, not volume tetrahedra!
            # The triangles define the outer surface AND internal hole surfaces.
            # Including tetrahedra creates a "web" through holes/cavities.
            for element in elements:
                if element['type'] == 'triangle':
                    tri = vtk.vtkTriangle()
                    for i, node_id in enumerate(element['nodes']):
                        tri.GetPointIds().SetId(i, node_map[node_id])
                    cells.InsertNextCell(tri)

            print(f"[DEBUG] Rendering {cells.GetNumberOfCells()} surface triangles (tets excluded)")

            # Create PolyData directly from triangles (no geometry filter needed)
            poly_data = vtk.vtkPolyData()
            poly_data.SetPoints(points)
            poly_data.SetPolys(cells)

            # Store for cross-section clipping
            self.current_poly_data = poly_data

            print(f"[DEBUG] PolyData created with {poly_data.GetNumberOfCells()} cells")

            # Add per-cell colors based on quality (if available)
            print(f"[DEBUG] About to check quality coloring conditions...")
            print(f"[DEBUG]   result exists: {result is not None}")
            print(f"[DEBUG]   quality_metrics in result: {'quality_metrics' in result if result else False}")
            print(f"[DEBUG]   per_element_quality in result: {'per_element_quality' in result if result else False}")

            if result and result.get('quality_metrics') and result.get('per_element_quality'):
                try:
                    print(f"[DEBUG] ENTERING quality coloring block!")
                    per_elem_quality = result['per_element_quality']
                    threshold = result['quality_metrics'].get('sicn_10_percentile', 0.3)

                    print(f"[DEBUG] Per-element quality data found: {len(per_elem_quality)} elements")
                    print(f"[DEBUG] Quality threshold (10th percentile): {threshold:.3f}")
                    print(f"[DEBUG] Number of elements to iterate: {len(elements)}")
                    print(f"[DEBUG] Element types: {set(e['type'] for e in elements)}")

                    # Create color array for cells
                    colors = vtk.vtkUnsignedCharArray()
                    colors.SetNumberOfComponents(3)
                    colors.SetName("Colors")

                    # Color each triangle based on adjacent tet quality
                    color_counts = {'red': 0, 'orange': 0, 'yellow': 0, 'yellow_green': 0, 'green': 0, 'default': 0}

                    for element in elements:
                        if element['type'] == 'triangle':
                            elem_id = element['id']
                            # Try both int and string keys (int for volumetric, string for JSON)
                            quality = per_elem_quality.get(elem_id, per_elem_quality.get(str(elem_id), None))

                            if quality is None:
                                # No quality data for this triangle - use default green
                                colors.InsertNextTuple3(51, 179, 102)
                                color_counts['default'] += 1
                            # Map quality to color
                            elif quality <= threshold:
                                # Worst 10% = RED
                                colors.InsertNextTuple3(255, 0, 0)
                                color_counts['red'] += 1
                            elif quality < 0.3:
                                # Poor = ORANGE
                                colors.InsertNextTuple3(255, 128, 0)
                                color_counts['orange'] += 1
                            elif quality < 0.5:
                                # Fair = YELLOW
                                colors.InsertNextTuple3(255, 255, 0)
                                color_counts['yellow'] += 1
                            elif quality < 0.7:
                                # Good = YELLOW-GREEN
                                colors.InsertNextTuple3(128, 255, 0)
                                color_counts['yellow_green'] += 1
                            else:
                                # Excellent = GREEN
                                colors.InsertNextTuple3(51, 179, 102)
                                color_counts['green'] += 1

                    poly_data.GetCellData().SetScalars(colors)
                    print(f"[DEBUG] [OK][OK]Applied per-triangle quality colors (threshold={threshold:.3f})")
                    print(f"[DEBUG] [OK][OK]Color distribution: {color_counts}")
                    print(f"[DEBUG] [OK][OK]Total colored triangles: {sum(color_counts.values())}")

                    # Verify scalars were set
                    check_scalars = poly_data.GetCellData().GetScalars()
                    print(f"[DEBUG] [OK][OK]Scalars check after SetScalars: {check_scalars.GetNumberOfTuples() if check_scalars else 'NONE'}")

                except Exception as e:
                    print(f"[DEBUG ERROR] Could not apply quality colors: {e}")
                    import traceback
                    print(f"[DEBUG ERROR] Traceback:")
                    traceback.print_exc()
            else:
                print(f"[DEBUG] Quality coloring conditions NOT met - skipping color application")

            mapper = vtk.vtkPolyDataMapper()
            mapper.SetInputData(poly_data)

            # Enable scalar coloring if quality colors were applied
            if result and result.get('per_element_quality') and poly_data.GetCellData().GetScalars():
                mapper.SetScalarModeToUseCellData()
                mapper.ScalarVisibilityOn()
                # CRITICAL: Tell VTK these are direct RGB colors (0-255), not scalar values
                mapper.SetColorModeToDirectScalars()
                print(f"[DEBUG] [OK][OK]Mapper configured for scalar coloring")
                print(f"[DEBUG] [OK][OK]ScalarVisibility: {mapper.GetScalarVisibility()}")
                print(f"[DEBUG] [OK][OK]ScalarMode: {mapper.GetScalarMode()}")
                print(f"[DEBUG] [OK][OK]ColorMode: DirectScalars (RGB 0-255)")
            else:
                mapper.ScalarVisibilityOff()
                print(f"[DEBUG] Scalar coloring disabled")

            self.current_actor = vtk.vtkActor()
            self.current_actor.SetMapper(mapper)

            # Set surface appearance - SOLID mesh visualization
            if not (result and result.get('per_element_quality')):
                # Only set uniform color if no per-element coloring
                self.current_actor.GetProperty().SetColor(0.2, 0.7, 0.4)  # Green

            self.current_actor.GetProperty().SetOpacity(1.0)  # Fully opaque

            # Use FLAT shading to show individual triangular facets
            # This makes the mesh structure visible instead of looking like smooth CAD
            self.current_actor.GetProperty().SetInterpolationToFlat()

            # Set material properties based on whether we have quality coloring
            if result and result.get('per_element_quality'):
                # Quality coloring: use high ambient to see colors clearly
                self.current_actor.GetProperty().SetAmbient(0.8)  # High ambient = bright colors
                self.current_actor.GetProperty().SetDiffuse(0.5)  # Lower diffuse
                self.current_actor.GetProperty().SetSpecular(0.0)  # No specular highlights
                print(f"[DEBUG] [OK][OK]Using high ambient lighting for quality visualization")
            else:
                # Normal mesh: balanced lighting
                self.current_actor.GetProperty().SetAmbient(0.4)  # Reflects ambient light
                self.current_actor.GetProperty().SetDiffuse(0.7)  # Main surface color
                self.current_actor.GetProperty().SetSpecular(0.2)  # Reduced specular for softer highlights
                self.current_actor.GetProperty().SetSpecularPower(15)  # Softer highlights

            # ALWAYS show mesh edges to distinguish mesh from CAD
            self.current_actor.GetProperty().EdgeVisibilityOn()
            self.current_actor.GetProperty().SetEdgeColor(0.0, 0.0, 0.0)  # Black edges
            self.current_actor.GetProperty().SetLineWidth(1.0)  # Visible edge width

            print(f"[DEBUG] Actor created, adding to renderer...")
            self.renderer.AddActor(self.current_actor)
            print(f"[DEBUG] Number of actors in renderer: {self.renderer.GetActors().GetNumberOfItems()}")

            self.renderer.ResetCamera()
            self.vtk_widget.GetRenderWindow().Render()
            print(f"[DEBUG] Render complete!")

            # Use result dict counts if available, otherwise parsed counts
            if result:
                display_nodes = result.get('total_nodes', len(nodes))
                display_elements = result.get('total_elements', len(elements))
            else:
                display_nodes = len(nodes)
                display_elements = len(elements)

            # Build info text with quality metrics if available
            info_lines = [
                f"<b>Mesh Generated</b><br>",
                f"{Path(filepath).name}<br>",
                f"<span style='color: #6c757d;'>",
                f"Nodes: {display_nodes:,} • Elements: {display_elements:,}<br>",
                f"Tetrahedra: {tet_count:,} • Triangles: {tri_count:,}"
            ]

            # Add quality metrics if available in result
            if result and result.get('quality_metrics'):
                metrics = result['quality_metrics']
                info_lines.append("<br><b>Quality Metrics (avg):</b><br>")

                # SICN (primary gmsh metric) - use AVERAGE not min
                if 'sicn_avg' in metrics:
                    sicn = metrics['sicn_avg']
                    sicn_color = "#198754" if sicn >= 0.7 else "#ffc107" if sicn >= 0.5 else "#dc3545"
                    info_lines.append(f"<span style='color: {sicn_color};'>SICN: {sicn:.3f}</span> ")

                # Gamma - use AVERAGE not min
                if 'gamma_avg' in metrics:
                    gamma = metrics['gamma_avg']
                    gamma_color = "#198754" if gamma >= 0.6 else "#ffc107" if gamma >= 0.4 else "#dc3545"
                    info_lines.append(f"<span style='color: {gamma_color};'>γ: {gamma:.3f}</span><br>")

                # Skewness - use AVERAGE not max
                if 'avg_skewness' in metrics:
                    skew = metrics['avg_skewness']
                    skew_color = "#198754" if skew <= 0.3 else "#ffc107" if skew <= 0.5 else "#dc3545"
                    info_lines.append(f"<span style='color: {skew_color};'>Skew: {skew:.3f}</span> ")

                # Aspect Ratio - use AVERAGE not max
                if 'avg_aspect_ratio' in metrics:
                    ar = metrics['avg_aspect_ratio']
                    ar_color = "#198754" if ar <= 2.0 else "#ffc107" if ar <= 3.0 else "#dc3545"
                    info_lines.append(f"<span style='color: {ar_color};'>AR: {ar:.2f}</span>")

            info_lines.append("</span>")
            info_text = "".join(info_lines)
            self.info_label.setText(info_text)
            self.info_label.adjustSize()  # Force label to resize to fit content
            print(f"[DEBUG] Info label updated: {info_text}")
            print(f"[DEBUG] load_mesh_file completed successfully!")
            return "SUCCESS"

        except Exception as e:
            error_msg = f"Error loading mesh: {str(e)}"
            print(f"[DEBUG ERROR] {error_msg}")
            import traceback
            traceback.print_exc()
            self.info_label.setText(error_msg)
            return f"ERROR: {e}"

    def _parse_msh_file(self, filepath: str):
        nodes = {}
        elements = []

        with open(filepath, 'r') as f:
            lines = f.readlines()

        i = 0
        while i < len(lines):
            line = lines[i].strip()

            if line == "$Nodes":
                i += 2
                while lines[i].strip() != "$EndNodes":
                    parts = lines[i].strip().split()
                    if len(parts) == 4:
                        num_nodes = int(parts[3])
                        i += 1
                        node_tags = []
                        for _ in range(num_nodes):
                            node_tags.append(int(lines[i].strip()))
                            i += 1
                        for tag in node_tags:
                            coords = lines[i].strip().split()
                            nodes[tag] = [float(coords[0]), float(coords[1]), float(coords[2])]
                            i += 1
                    else:
                        i += 1

            elif line == "$Elements":
                i += 2
                while lines[i].strip() != "$EndElements":
                    parts = lines[i].strip().split()
                    if len(parts) == 4:
                        element_type = int(parts[2])
                        num_elements = int(parts[3])
                        i += 1

                        # Handle linear tetrahedra (4-node)
                        if element_type == 4:
                            for _ in range(num_elements):
                                data = lines[i].strip().split()
                                if len(data) >= 5:
                                    elements.append({
                                        "id": int(data[0]),
                                        "type": "tetrahedron",
                                        "nodes": [int(data[1]), int(data[2]), int(data[3]), int(data[4])]
                                    })
                                i += 1
                        # Handle quadratic tetrahedra (10-node) - use first 4 corner nodes
                        elif element_type == 11:
                            for _ in range(num_elements):
                                data = lines[i].strip().split()
                                if len(data) >= 11:  # 10 nodes + element tag
                                    elements.append({
                                        "id": int(data[0]),
                                        "type": "tetrahedron",
                                        "nodes": [int(data[1]), int(data[2]), int(data[3]), int(data[4])]
                                    })
                                i += 1
                        # Handle linear triangles (3-node)
                        elif element_type == 2:
                            for _ in range(num_elements):
                                data = lines[i].strip().split()
                                if len(data) >= 4:
                                    elements.append({
                                        "id": int(data[0]),
                                        "type": "triangle",
                                        "nodes": [int(data[1]), int(data[2]), int(data[3])]
                                    })
                                i += 1
                        # Handle quadratic triangles (6-node) - use first 3 corner nodes
                        elif element_type == 9:
                            for _ in range(num_elements):
                                data = lines[i].strip().split()
                                if len(data) >= 7:  # 6 nodes + element tag
                                    elements.append({
                                        "id": int(data[0]),
                                        "type": "triangle",
                                        "nodes": [int(data[1]), int(data[2]), int(data[3])]
                                    })
                                i += 1
                        else:
                            # Skip other element types (edges, points, etc.)
                            for _ in range(num_elements):
                                i += 1
                    else:
                        i += 1
            else:
                i += 1

        return nodes, elements


class ModernMeshGenGUI(QMainWindow):
    """Final polished GUI with AI chatbox"""

    def __init__(self):
        super().__init__()
        self.cad_file = None
        self.mesh_file = None
        self.worker = MeshWorker()
        self.phase_bars = {}
        self.phase_labels = {}
        self.phase_base_names = {}
        self.active_phase = None
        self.dot_count = 0

        # AI chatbox
        self.chatbox = None
        self.chatbox_visible = False

        # Paintbrush refinement
        self.paintbrush_selector = None
        self.paintbrush_widget = None
        if PAINTBRUSH_AVAILABLE:
            self.paintbrush_selector = PaintbrushSelector()

        # Animation timer for jumping dots
        self.animation_timer = QTimer(self)
        self.animation_timer.timeout.connect(self.update_animation)
        self.animation_timer.setInterval(400)  # Update every 400ms

        self.worker.signals.log.connect(self.add_log)
        self.worker.signals.progress.connect(self.update_progress)
        self.worker.signals.phase_complete.connect(self.mark_phase_complete)
        self.worker.signals.finished.connect(self.on_mesh_finished)

        self.init_ui()

    def init_ui(self):
        self.setWindowTitle("Khorium MeshGen - Parallel Edition")
        self.setGeometry(100, 50, 1600, 850)  # Reduced height to fit more screens

        palette = QPalette()
        palette.setColor(QPalette.Window, QColor(248, 249, 250))
        palette.setColor(QPalette.WindowText, QColor(33, 37, 41))
        palette.setColor(QPalette.Base, QColor(255, 255, 255))
        palette.setColor(QPalette.Text, QColor(33, 37, 41))
        palette.setColor(QPalette.Button, QColor(255, 255, 255))
        palette.setColor(QPalette.ButtonText, QColor(33, 37, 41))
        self.setPalette(palette)

        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout(central)
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(0, 0, 0, 0)

        # Create a container for left panel and chatbox (they'll swap)
        self.left_container = QWidget()
        left_container_layout = QVBoxLayout(self.left_container)
        left_container_layout.setContentsMargins(0, 0, 0, 0)
        left_container_layout.setSpacing(0)

        # Create left panel
        logging.info("Creating left panel...")
        self.left_panel = self.create_left_panel()
        left_container_layout.addWidget(self.left_panel)
        logging.info("Left panel created successfully")

        # Try to create chatbox (optional - may fail if dependencies not installed)
        logging.info("Attempting to initialize chatbox...")
        try:
            logging.info("Importing ChatboxWidget from ui.chatbox_widget...")
            from ui.chatbox_widget import ChatboxWidget
            logging.info("ChatboxWidget imported successfully")

            logging.info("Creating ChatboxWidget instance...")
            self.chatbox = ChatboxWidget()
            logging.info(f"ChatboxWidget instance created: {self.chatbox}")

            self.chatbox.setVisible(False)  # Hidden by default
            left_container_layout.addWidget(self.chatbox)

            # Connect close button signal to toggle function
            self.chatbox.close_requested.connect(self.toggle_chatbox)

            logging.info("AI chatbox initialized successfully")
            print("AI chatbox initialized successfully")

            # Re-enable the chat button now that chatbox is available
            if hasattr(self, 'chat_toggle_btn'):
                logging.info("Re-enabling chat button...")
                self.chat_toggle_btn.setEnabled(True)
                self.chat_toggle_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #0d6efd;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 5px;
                        font-size: 12px;
                        font-weight: bold;
                    }
                    QPushButton:hover { background-color: #0b5ed7; }
                    QPushButton:checked {
                        background-color: #198754;
                    }
                """)
                self.chat_toggle_btn.setToolTip("Toggle AI assistant (Claude)")
                logging.info("Chat button re-enabled successfully")
                print("Chat button re-enabled")
            else:
                logging.warning("chat_toggle_btn not found - cannot re-enable")
        except ImportError as e:
            logging.error(f"ImportError during chatbox initialization: {e}")
            print(f"⚠ AI chatbox not available (ImportError): {e}")
            print("  Install dependencies: pip install anthropic python-dotenv")
            self.chatbox = None
        except Exception as e:
            logging.error(f"Exception during chatbox initialization: {e}")
            logging.error(f"Exception type: {type(e)}")
            import traceback
            logging.error(f"Traceback: {traceback.format_exc()}")
            print(f"AI chatbox initialization failed: {e}")
            traceback.print_exc()
            self.chatbox = None

        main_layout.addWidget(self.left_container)

        logging.info("Creating right panel...")
        right_panel = self.create_right_panel()
        main_layout.addWidget(right_panel, 1)
        logging.info("Right panel created successfully")

        logging.info("="*60)
        logging.info("init_ui() completed successfully")
        logging.info(f"Final chatbox status: {self.chatbox}")
        logging.info("="*60)

    def create_left_panel(self):
        panel = QFrame()
        panel.setMaximumWidth(380)
        panel.setStyleSheet("QFrame { background-color: white; border-right: 1px solid #dee2e6; }")

        # Use scroll area to handle overflow
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.NoFrame)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll.setStyleSheet("QScrollArea { background-color: white; border: none; }")

        # Content widget inside scroll area
        content_widget = QWidget()
        layout = QVBoxLayout(content_widget)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(10)  # Reduced from 15

        # Header with title and chat button
        header_layout = QHBoxLayout()

        title = QLabel("Khorium MeshGen")
        title.setFont(QFont("Arial", 18, QFont.Bold))
        header_layout.addWidget(title)

        header_layout.addStretch()

        # AI Chat toggle button
        self.chat_toggle_btn = QPushButton("💬 AI Chat")
        self.chat_toggle_btn.setStyleSheet("""
            QPushButton {
                background-color: #0d6efd;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 5px;
                font-size: 12px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #0b5ed7; }
            QPushButton:checked {
                background-color: #198754;
            }
        """)
        self.chat_toggle_btn.setCheckable(True)
        self.chat_toggle_btn.clicked.connect(self.toggle_chatbox)
        self.chat_toggle_btn.setToolTip("Toggle AI assistant (Claude)")
        logging.info(f"Checking chatbox status: self.chatbox = {self.chatbox}")
        if not self.chatbox:
            logging.warning("Chatbox is None - disabling button")
            self.chat_toggle_btn.setEnabled(False)
            self.chat_toggle_btn.setStyleSheet("""
                QPushButton {
                    background-color: #6c757d;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 5px;
                    font-size: 12px;
                    font-weight: bold;
                    opacity: 0.6;
                }
            """)
            self.chat_toggle_btn.setToolTip("AI Chat unavailable - Check /tmp/meshgen_gui_debug.log")
            print(f"[DEBUG] Chat button disabled - chatbox is None")
            logging.info("Chat button set to disabled state")
        else:
            logging.info("Chatbox is initialized - enabling button")
            print(f"[DEBUG] Chat button enabled - chatbox initialized")
            logging.info("Chat button set to enabled state")
        header_layout.addWidget(self.chat_toggle_btn)

        layout.addLayout(header_layout)

        subtitle = QLabel("Parallel Mesh Generation (3-5x Faster)")
        subtitle.setFont(QFont("Arial", 10))
        subtitle.setStyleSheet("color: #198754; font-weight: bold;")
        layout.addWidget(subtitle)

        # System info
        from multiprocessing import cpu_count
        cores = cpu_count()
        workers = max(1, cores - 2)
        system_info = QLabel(f"System: {cores} cores | {workers} parallel workers")
        system_info.setFont(QFont("Arial", 9))
        system_info.setStyleSheet("color: #6c757d; padding: 5px 0;")
        layout.addWidget(system_info)

        # Upload section
        upload_group = QGroupBox("Load CAD File")
        upload_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 1px solid #dee2e6;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                color: #212529;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #212529;
            }
        """)
        upload_layout = QVBoxLayout()

        self.load_btn = QPushButton("Browse CAD File")
        self.load_btn.setStyleSheet("""
            QPushButton {
                background-color: #0d6efd;
                color: white;
                border: none;
                padding: 12px;
                border-radius: 5px;
                font-size: 13px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #0b5ed7; }
        """)
        self.load_btn.clicked.connect(self.load_cad_file)
        upload_layout.addWidget(self.load_btn)

        self.file_label = QLabel("No file loaded")
        self.file_label.setWordWrap(True)
        self.file_label.setStyleSheet("color: #6c757d; font-size: 11px;")
        upload_layout.addWidget(self.file_label)

        upload_group.setLayout(upload_layout)
        layout.addWidget(upload_group)

        # Mesh Quality Settings
        quality_group = QGroupBox("Mesh Quality Settings")
        quality_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 1px solid #dee2e6;
                border-radius: 5px;
                margin-top: 12px;
                padding-top: 12px;
                color: #212529;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #212529;
            }
        """)
        quality_layout = QVBoxLayout()
        quality_layout.setSpacing(10)

        # Quality preset dropdown
        preset_layout = QHBoxLayout()
        preset_label = QLabel("Quality Preset:")
        preset_label.setStyleSheet("font-size: 11px; color: #495057;")
        preset_layout.addWidget(preset_label)

        self.quality_preset = QComboBox()
        self.quality_preset.addItems(["Coarse", "Medium", "Fine", "Very Fine", "Custom"])
        self.quality_preset.setCurrentIndex(1)  # Default to Medium
        self.quality_preset.setStyleSheet("""
            QComboBox {
                padding: 5px;
                border: 1px solid #ced4da;
                border-radius: 4px;
                background-color: white;
                color: black;
                font-size: 11px;
            }
        """)
        self.quality_preset.currentTextChanged.connect(self.on_quality_preset_changed)
        preset_layout.addWidget(self.quality_preset, 1)
        quality_layout.addLayout(preset_layout)

        # Target element count
        target_layout = QHBoxLayout()
        target_label = QLabel("Target Elements:")
        target_label.setStyleSheet("font-size: 11px; color: #495057;")
        target_layout.addWidget(target_label)

        self.target_elements = QSpinBox()
        self.target_elements.setRange(100, 1000000)
        self.target_elements.setValue(10000)
        self.target_elements.setSingleStep(1000)
        self.target_elements.setStyleSheet("""
            QSpinBox {
                padding: 5px;
                border: 1px solid #ced4da;
                border-radius: 4px;
                background-color: white;
                color: #212529;
                font-size: 11px;
            }
            QSpinBox::up-button, QSpinBox::down-button {
                width: 16px;
                background-color: #f8f9fa;
                border: 1px solid #ced4da;
            }
            QSpinBox::up-button:hover, QSpinBox::down-button:hover {
                background-color: #e9ecef;
            }
        """)
        target_layout.addWidget(self.target_elements, 1)
        quality_layout.addLayout(target_layout)

        # Max element size only (ANSYS-style) - label and control on same line
        size_layout = QHBoxLayout()
        size_label = QLabel("Max Element Size:")
        size_label.setStyleSheet("font-size: 11px; color: #495057;")
        size_layout.addWidget(size_label)

        self.max_size = QSpinBox()
        self.max_size.setRange(1, 10000)
        self.max_size.setValue(100)
        self.max_size.setSuffix(" mm")
        self.max_size.setFixedWidth(100)  # Compact width
        self.max_size.setButtonSymbols(QSpinBox.UpDownArrows)
        self.max_size.setStyleSheet("""
            QSpinBox {
                padding: 4px;
                border: 1px solid #ced4da;
                border-radius: 4px;
                background-color: white;
                color: #212529;
                font-size: 11px;
            }
        """)
        size_layout.addWidget(self.max_size, 1)
        quality_layout.addLayout(size_layout)

        # Mesh strategy selector
        strategy_layout = QHBoxLayout()
        strategy_label = QLabel("Mesh Strategy:")
        strategy_label.setStyleSheet("font-size: 11px; color: #495057;")
        strategy_layout.addWidget(strategy_label)

        self.mesh_strategy = QComboBox()
        self.mesh_strategy.addItems([
            "Tetrahedral (Delaunay)",
            "Tetrahedral (Frontal)",
            "Tetrahedral (HXT - Parallel)",
            "Polyhedral (Tet→Poly)",
            "Hexahedral (Tet→Hex)",
            "Hex-Dominant (Recombined)",
            "Quad-Dominant (2D)"
        ])
        self.mesh_strategy.setCurrentIndex(0)  # Default to Delaunay
        self.mesh_strategy.setToolTip(
            "Tetrahedral (Delaunay): Best for general use, robust\n"
            "Tetrahedral (Frontal): Good for boundary layers\n"
            "Tetrahedral (HXT): Fast parallel meshing\n"
            "Polyhedral (Tet→Poly): CFD-optimized polyhedral cells (ANSYS/OpenFOAM style)\n"
            "Hexahedral (Tet→Hex): Converts tets to hexes via THex splitting (4x elements)\n"
            "Hex-Dominant: Creates hexahedral elements (experimental)\n"
            "Quad-Dominant: 2D quadrilateral meshes"
        )
        self.mesh_strategy.setStyleSheet("""
            QComboBox {
                padding: 5px;
                border: 1px solid #ced4da;
                border-radius: 4px;
                background-color: white;
                color: black;
                font-size: 11px;
            }
        """)
        strategy_layout.addWidget(self.mesh_strategy, 1)
        quality_layout.addLayout(strategy_layout)

        # Curvature-adaptive checkbox - clean, no emoji/description
        self.curvature_adaptive = QCheckBox("Curvature-Adaptive Meshing")
        self.curvature_adaptive.setChecked(False)
        self.curvature_adaptive.setStyleSheet("""
            QCheckBox {
                font-size: 11px;
                color: #212529;
                spacing: 5px;
                margin-top: 8px;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                background-color: white;
                border: 2px solid #6c757d;
                border-radius: 3px;
            }
            QCheckBox::indicator:checked {
                background-color: #198754;
                border: 2px solid #198754;
            }
            QCheckBox::indicator:checked {
                image: none;
            }
        """)
        quality_layout.addWidget(self.curvature_adaptive)

        quality_group.setLayout(quality_layout)
        layout.addWidget(quality_group)

        # Cross-Section Viewer
        crosssection_group = QGroupBox("Cross-Section Viewer")
        crosssection_group.setStyleSheet("""
            QGroupBox {
                font-weight: 600;
                font-size: 12px;
                color: #2c3e50;
                border: 1px solid #dee2e6;
                border-radius: 6px;
                margin-top: 8px;
                padding-top: 12px;
                background-color: #f8f9fa;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top left;
                padding: 0 5px;
                background-color: #f8f9fa;
            }
        """)
        crosssection_layout = QVBoxLayout()
        crosssection_layout.setSpacing(8)

        # Enable cross-section checkbox
        self.crosssection_enabled = QCheckBox("Enable Cross-Section")
        self.crosssection_enabled.setStyleSheet("font-size: 11px; color: #495057;")
        self.crosssection_enabled.setChecked(False)
        self.crosssection_enabled.stateChanged.connect(self.on_crosssection_toggled)
        crosssection_layout.addWidget(self.crosssection_enabled)

        # Axis selection dropdown
        axis_layout = QHBoxLayout()
        axis_label = QLabel("Clip Axis:")
        axis_label.setStyleSheet("font-size: 11px; color: #495057;")
        axis_layout.addWidget(axis_label)

        self.clip_axis_combo = QComboBox()
        self.clip_axis_combo.addItems(["X", "Y", "Z"])
        self.clip_axis_combo.setCurrentText("Z")
        self.clip_axis_combo.setEnabled(False)
        self.clip_axis_combo.setStyleSheet("""
            QComboBox {
                padding: 4px;
                border: 1px solid #ced4da;
                border-radius: 4px;
                background-color: white;
                color: #212529;
                font-size: 11px;
            }
            QComboBox:disabled {
                background-color: #e9ecef;
                color: #6c757d;
            }
        """)
        self.clip_axis_combo.currentTextChanged.connect(self.on_clip_axis_changed)
        axis_layout.addWidget(self.clip_axis_combo, 1)
        crosssection_layout.addLayout(axis_layout)

        # Offset slider
        offset_layout = QVBoxLayout()
        offset_layout.setSpacing(3)

        offset_label_layout = QHBoxLayout()
        offset_label = QLabel("Offset:")
        offset_label.setStyleSheet("font-size: 11px; color: #495057;")
        offset_label_layout.addWidget(offset_label)

        self.clip_offset_value_label = QLabel("0%")
        self.clip_offset_value_label.setStyleSheet("font-size: 11px; color: #007bff; font-weight: 600;")
        self.clip_offset_value_label.setAlignment(Qt.AlignRight)
        offset_label_layout.addWidget(self.clip_offset_value_label)
        offset_layout.addLayout(offset_label_layout)

        self.clip_offset_slider = QSlider(Qt.Horizontal)
        self.clip_offset_slider.setRange(-50, 50)
        self.clip_offset_slider.setValue(0)
        self.clip_offset_slider.setEnabled(False)
        self.clip_offset_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                height: 6px;
                background: #e9ecef;
                border-radius: 3px;
            }
            QSlider::handle:horizontal {
                background: #007bff;
                width: 14px;
                height: 14px;
                margin: -4px 0;
                border-radius: 7px;
            }
            QSlider::handle:horizontal:hover {
                background: #0056b3;
            }
            QSlider::handle:horizontal:disabled {
                background: #6c757d;
            }
        """)
        self.clip_offset_slider.valueChanged.connect(self.on_clip_offset_changed)
        offset_layout.addWidget(self.clip_offset_slider)
        crosssection_layout.addLayout(offset_layout)

        crosssection_group.setLayout(crosssection_layout)
        layout.addWidget(crosssection_group)

        # Paintbrush refinement widget
        print(f"[DEBUG] Paintbrush available: {PAINTBRUSH_AVAILABLE}")
        print(f"[DEBUG] Paintbrush selector: {self.paintbrush_selector}")

        if PAINTBRUSH_AVAILABLE and self.paintbrush_selector:
            try:
                print("[DEBUG] Creating paintbrush widget...")
                self.paintbrush_widget = PaintbrushWidget()
                print("[DEBUG] Paintbrush widget created successfully")

                self.paintbrush_widget.paintbrush_enabled.connect(self.on_paintbrush_toggled)
                self.paintbrush_widget.radius_changed.connect(self.on_brush_radius_changed)
                self.paintbrush_widget.refinement_changed.connect(self.on_refinement_changed)
                self.paintbrush_widget.clear_requested.connect(self.on_clear_painted_regions)
                self.paintbrush_widget.preview_requested.connect(self.on_preview_refinement)
                self.paintbrush_widget.region_deleted.connect(self.on_region_deleted)

                print("[DEBUG] Adding paintbrush widget to layout...")
                layout.addWidget(self.paintbrush_widget)
                print("[DEBUG] Paintbrush widget added to GUI!")
            except Exception as e:
                print(f"[ERROR] Failed to create paintbrush widget: {e}")
                import traceback
                traceback.print_exc()
        else:
            print(f"[DEBUG] Paintbrush widget NOT added - Available:{PAINTBRUSH_AVAILABLE}, Selector:{self.paintbrush_selector}")

        # Generate button
        self.generate_btn = QPushButton("Generate Mesh (Parallel)")
        self.generate_btn.setEnabled(False)
        self.generate_btn.setStyleSheet("""
            QPushButton {
                background-color: #198754;
                color: white;
                border: none;
                padding: 15px;
                border-radius: 5px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover:enabled { background-color: #157347; }
            QPushButton:disabled { background-color: #e9ecef; color: #adb5bd; }
        """)
        self.generate_btn.clicked.connect(self.start_mesh_generation)
        layout.addWidget(self.generate_btn)

        # Progress bars - COMPACT
        progress_group = QGroupBox("Progress")
        progress_group.setStyleSheet("""
            QGroupBox {
                font-weight: bold;
                border: 1px solid #dee2e6;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                color: #212529;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #212529;
            }
        """)
        progress_layout = QVBoxLayout()
        progress_layout.setSpacing(3)  # More compact spacing

        phases = [
            ("strategy", "Strategy"),
            ("1d", "1D"),
            ("2d", "2D"),
            ("3d", "3D"),
            ("opt", "Optimize"),
            ("netgen", "Netgen"),
            ("order2", "Order 2"),
            ("quality", "Quality")
        ]

        for phase_id, phase_name in phases:
            phase_label = QLabel(phase_name)
            phase_label.setStyleSheet("font-size: 8px; color: #495057; font-weight: 600;")
            progress_layout.addWidget(phase_label)

            # Store label reference and base name for animation
            self.phase_labels[phase_id] = phase_label
            self.phase_base_names[phase_id] = phase_name

            phase_bar = QProgressBar()
            phase_bar.setStyleSheet("""
                QProgressBar {
                    border: 1px solid #dee2e6;
                    border-radius: 2px;
                    text-align: center;
                    background-color: #f8f9fa;
                    height: 14px;
                    font-size: 8px;
                    font-weight: bold;
                }
                QProgressBar::chunk {
                    background-color: #0d6efd;
                    border-radius: 1px;
                }
            """)
            phase_bar.setMaximum(100)
            phase_bar.setValue(0)
            phase_bar.setFormat("%p%")  # Only show percentage
            progress_layout.addWidget(phase_bar)

            self.phase_bars[phase_id] = phase_bar

        progress_group.setLayout(progress_layout)
        layout.addWidget(progress_group)

        layout.addStretch()

        # Add content to scroll area
        scroll.setWidget(content_widget)

        # Add scroll area to panel
        panel_layout = QVBoxLayout(panel)
        panel_layout.setContentsMargins(0, 0, 0, 0)
        panel_layout.addWidget(scroll)

        return panel

    def create_right_panel(self):
        panel = QWidget()
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Viewer controls
        controls = QFrame()
        controls.setStyleSheet("background-color: #f8f9fa; border-bottom: 1px solid #dee2e6;")
        controls_layout = QHBoxLayout(controls)
        controls_layout.setContentsMargins(10, 5, 10, 5)

        axes_cb = QCheckBox("Show XYZ Axes")
        axes_cb.setChecked(True)
        axes_cb.setStyleSheet("QCheckBox { color: black; font-size: 11px; }")
        axes_cb.stateChanged.connect(lambda s: self.viewer.toggle_axes(s == Qt.Checked))
        controls_layout.addWidget(axes_cb)
        controls_layout.addStretch()

        layout.addWidget(controls)

        # 3D Viewer
        self.viewer = VTK3DViewer()
        layout.addWidget(self.viewer, 2)

        # Console
        console_frame = QFrame()
        console_frame.setStyleSheet("QFrame { background-color: white; border-top: 1px solid #dee2e6; }")
        console_layout = QVBoxLayout(console_frame)
        console_layout.setContentsMargins(10, 10, 10, 10)

        # Console header with copy button
        console_header_layout = QHBoxLayout()
        console_header = QLabel("Console")
        console_header.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        console_header_layout.addWidget(console_header)

        copy_console_btn = QPushButton("Copy Console")
        copy_console_btn.setMaximumWidth(120)
        copy_console_btn.setStyleSheet("""
            QPushButton {
                background-color: #6c757d;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px 12px;
                font-size: 11px;
            }
            QPushButton:hover {
                background-color: #5a6268;
            }
            QPushButton:pressed {
                background-color: #545b62;
            }
        """)
        copy_console_btn.clicked.connect(self.copy_console_to_clipboard)
        console_header_layout.addStretch()
        console_header_layout.addWidget(copy_console_btn)
        console_layout.addLayout(console_header_layout)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setMaximumHeight(200)
        self.console.setStyleSheet("""
            QTextEdit {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                font-family: 'Courier New', monospace;
                font-size: 10px;
                color: #212529;
                padding: 8px;
            }
        """)
        console_layout.addWidget(self.console)

        layout.addWidget(console_frame)
        return panel

    def calculate_suggested_element_counts(self, geom_info: dict):
        """Calculate appropriate element counts based on geometry size"""
        volume = geom_info.get('volume', 0.001)  # cubic meters
        bbox_diag = geom_info.get('bbox_diagonal', 1.0)  # meters

        # Work backwards: Given desired element count, calculate mesh size
        # Formula: element_size = (volume / num_elements)^(1/3)
        # Then set min/max around this average size

        # Helper function to calculate sizes from target count
        def calc_sizes(target_elements):
            avg_size_m = (volume / target_elements) ** (1/3)  # meters
            avg_size_mm = avg_size_m * 1000  # convert to mm

            # Set min/max as ±30% of average
            min_mm = max(0.1, avg_size_mm * 0.7)
            max_mm = max(0.5, avg_size_mm * 1.3)

            return int(target_elements), int(round(min_mm)), int(round(max_mm))

        # Coarse: ~500-2000 elements (fast preview)
        target_coarse = max(500, min(2000, int(volume * 1e6)))  # ~1mm³ per element
        count_c, min_c, max_c = calc_sizes(target_coarse)

        # Medium: ~2000-8000 elements (balanced)
        target_medium = max(2000, min(8000, int(volume * 4e6)))  # ~0.25mm³ per element
        count_m, min_m, max_m = calc_sizes(target_medium)

        # Fine: ~8000-30000 elements (high quality)
        target_fine = max(8000, min(30000, int(volume * 16e6)))  # ~0.0625mm³ per element
        count_f, min_f, max_f = calc_sizes(target_fine)

        # Very Fine: ~30000-100000 elements (max quality)
        target_vfine = max(30000, min(100000, int(volume * 64e6)))  # ~0.015625mm³ per element
        count_vf, min_vf, max_vf = calc_sizes(target_vfine)

        presets = {
            "Coarse": {"target": count_c, "max": max_c},
            "Medium": {"target": count_m, "max": max_m},
            "Fine": {"target": count_f, "max": max_f},
            "Very Fine": {"target": count_vf, "max": max_vf}
        }

        # Store calculated presets for future use
        self.calculated_presets = presets

        # Update current preset values
        current_preset = self.quality_preset.currentText()
        if current_preset in presets:
            values = presets[current_preset]
            self.target_elements.setValue(values["target"])
            self.max_size.setValue(values["max"])
            self.add_log(f"Calculated element counts for geometry (volume={volume:.6f} m³):")
            self.add_log(f"   Coarse: ~{count_c:,} elements (max size: {max_c:.1f} mm)")
            self.add_log(f"   Medium: ~{count_m:,} elements (max size: {max_m:.1f} mm)")
            self.add_log(f"   Fine: ~{count_f:,} elements (max size: {max_f:.1f} mm)")
            self.add_log(f"   Very Fine: ~{count_vf:,} elements (max size: {max_vf:.1f} mm)")

    def on_quality_preset_changed(self, preset: str):
        """Update mesh quality settings based on preset"""
        # Use calculated presets if available, otherwise use defaults
        if hasattr(self, 'calculated_presets') and preset in self.calculated_presets:
            presets = self.calculated_presets
        else:
            presets = {
                "Coarse": {"target": 5000, "max": 200},
                "Medium": {"target": 10000, "max": 100},
                "Fine": {"target": 50000, "max": 50},
                "Very Fine": {"target": 200000, "max": 20}
            }

        presets["Custom"] = None  # Don't change values for custom

        if preset in presets and presets[preset]:
            values = presets[preset]
            self.target_elements.setValue(values["target"])
            self.max_size.setValue(values["max"])

    def load_cad_file(self):
        # Use cad_files folder as default
        default_dir = str(Path(__file__).parent / "cad_files")
        if not Path(default_dir).exists():
            default_dir = str(Path.home())

        filepath, _ = QFileDialog.getOpenFileName(
            self, "Select CAD File", default_dir,
            "CAD Files (*.step *.stp *.stl);;All Files (*)"
        )

        if filepath:
            self.cad_file = filepath
            self.file_label.setText(f"{Path(filepath).name}")
            self.generate_btn.setEnabled(True)
            self.add_log(f"Loaded: {filepath}")

            # Clear any existing AI iteration meshes
            self.viewer.clear_iterations()

            # Load CAD and get geometry info
            geom_info = self.viewer.load_step_file(filepath)

            # Load geometry for paintbrush (after CAD is loaded)
            if self.paintbrush_selector:
                try:
                    import gmsh
                    gmsh.initialize()
                    gmsh.open(filepath)
                    if self.paintbrush_selector.load_cad_geometry():
                        self.add_log(f"Paintbrush: Loaded {len(self.paintbrush_selector.available_surfaces)} surfaces")
                    gmsh.finalize()
                except Exception as e:
                    print(f"Could not load geometry for paintbrush: {e}")

            # Calculate suggested element counts based on geometry
            if geom_info and 'volume' in geom_info:
                self.calculate_suggested_element_counts(geom_info)
            else:
                self.add_log("⚠ Could not calculate geometry volume - using default element counts")

    def start_mesh_generation(self):
        if not self.cad_file:
            return

        self.generate_btn.setEnabled(False)
        self.console.clear()

        for bar in self.phase_bars.values():
            bar.setValue(0)
            bar.setStyleSheet(bar.styleSheet().replace("background-color: #198754", "background-color: #0d6efd"))

        # Collect quality parameters from GUI
        quality_params = {
            "quality_preset": self.quality_preset.currentText(),
            "target_elements": self.target_elements.value(),
            "max_size_mm": self.max_size.value(),
            "curvature_adaptive": self.curvature_adaptive.isChecked(),
            "mesh_strategy": self.mesh_strategy.currentText()
        }

        # Store for chatbox experiments
        self.last_quality_params = quality_params

        self.add_log("=" * 70)
        self.add_log("Starting PARALLEL mesh generation...")
        self.add_log(f"Quality: {quality_params['quality_preset']}, Target: {quality_params['target_elements']:,} elements")
        self.add_log(f"Max element size: {quality_params['max_size_mm']} mm (ANSYS-style, no minimum)")
        self.add_log(f"Strategy: {quality_params['mesh_strategy']}")
        if quality_params['curvature_adaptive']:
            self.add_log(f"Curvature-Adaptive: ON")
        self.add_log(f"Parallel execution will test multiple strategies simultaneously")
        self.add_log("=" * 70)

        self.worker.start(self.cad_file, quality_params)

    def add_log(self, message: str):
        self.console.append(message)
        self.console.verticalScrollBar().setValue(self.console.verticalScrollBar().maximum())

    def copy_console_to_clipboard(self):
        """Copy all console text to clipboard"""
        clipboard = QApplication.clipboard()
        console_text = self.console.toPlainText()
        clipboard.setText(console_text)
        self.add_log("Console output copied to clipboard!")

    def update_progress(self, phase: str, percentage: int):
        """Update progress bar and animate phase label"""
        if phase in self.phase_bars:
            bar = self.phase_bars[phase]
            bar.setValue(percentage)

            # Start animation if this is a new active phase
            if self.active_phase != phase:
                self.active_phase = phase
                self.dot_count = 0
                if not self.animation_timer.isActive():
                    self.animation_timer.start()

    def mark_phase_complete(self, phase: str):
        """Turn bar green when complete and reset label"""
        if phase in self.phase_bars:
            bar = self.phase_bars[phase]
            bar.setValue(100)
            # Change to green
            bar.setStyleSheet("""
                QProgressBar {
                    border: 1px solid #198754;
                    border-radius: 4px;
                    text-align: center;
                    background-color: #d1e7dd;
                    height: 24px;
                    font-size: 11px;
                    font-weight: bold;
                }
                QProgressBar::chunk {
                    background-color: #198754;
                    border-radius: 3px;
                }
            """)

            # Reset label to base name (remove dots)
            if phase in self.phase_labels and phase in self.phase_base_names:
                self.phase_labels[phase].setText(self.phase_base_names[phase])

    def update_animation(self):
        """Update the animated dots for the active phase"""
        if self.active_phase and self.active_phase in self.phase_labels:
            # Cycle through 0, 1, 2, 3 dots
            self.dot_count = (self.dot_count + 1) % 4

            # Create animated dots with vertical offset effect
            dots = ['⠀', '⠄', '⠆', '⠇']  # Braille dots that look like jumping dots
            # Or use simpler dots:
            # dots = ['.  ', '.. ', '...', '   ']
            dots_simple = ['   ', '.  ', '.. ', '...']

            base_name = self.phase_base_names[self.active_phase]
            animated_text = f"{base_name}{dots_simple[self.dot_count]}"

            self.phase_labels[self.active_phase].setText(animated_text)

    def on_mesh_finished(self, success: bool, result: dict):
        self.add_log("[DEBUG] on_mesh_finished CALLBACK TRIGGERED!")
        self.add_log(f"[DEBUG] success: {success}")
        self.add_log(f"[DEBUG] result keys: {list(result.keys()) if result else 'None'}")

        # Stop animation timer
        if self.animation_timer.isActive():
            self.animation_timer.stop()
        self.active_phase = None

        self.generate_btn.setEnabled(True)

        if success:
            self.add_log("=" * 70)
            self.add_log("MESH GENERATION COMPLETE")
            self.add_log("=" * 70)

            self.mesh_file = result.get('output_file')
            metrics = result.get('metrics', {})

            self.add_log(f"[DEBUG] mesh_file: {self.mesh_file}")
            self.add_log(f"[DEBUG] File exists: {Path(self.mesh_file).exists() if self.mesh_file else 'N/A'}")

            if self.mesh_file and Path(self.mesh_file).exists():
                self.add_log(f"[DEBUG] Calling viewer.load_mesh_file...")
                load_result = self.viewer.load_mesh_file(self.mesh_file, result)  # Pass result dict!
                self.add_log(f"[DEBUG] load_mesh_file returned: {load_result}")

                # Check if colors were applied
                if self.viewer.current_actor and result.get('per_element_quality'):
                    mapper = self.viewer.current_actor.GetMapper()
                    poly_data = mapper.GetInput()
                    scalars = poly_data.GetCellData().GetScalars()
                    self.add_log(f"[DEBUG] Actor has {poly_data.GetNumberOfCells()} cells")
                    self.add_log(f"[DEBUG] Scalars array: {scalars.GetNumberOfTuples() if scalars else 'NONE'} tuples")
                    self.add_log(f"[DEBUG] Mapper ScalarVisibility: {mapper.GetScalarVisibility()}")
                    self.add_log(f"[DEBUG] Mapper ColorMode: {mapper.GetColorMode()}")
                    if scalars:
                        # Sample first few colors
                        sample_colors = []
                        for i in range(min(5, scalars.GetNumberOfTuples())):
                            color = scalars.GetTuple3(i)
                            sample_colors.append(f"({int(color[0])},{int(color[1])},{int(color[2])})")
                        self.add_log(f"[DEBUG] First 5 colors: {', '.join(sample_colors)}")

                self.add_log(f"[DEBUG] Calling viewer.show_quality_report...")
                self.viewer.show_quality_report(metrics)
                self.add_log(f"[DEBUG] on_mesh_finished complete!")

                # Update chatbox with mesh data, CAD file, and config
                if self.chatbox:
                    mesh_data = {
                        'file_name': Path(self.mesh_file).name,
                        'total_elements': result.get('total_elements', 0),
                        'total_nodes': result.get('total_nodes', 0),
                        **metrics
                    }

                    # Pass CAD file and config for experiments
                    config = getattr(self, 'last_quality_params', {
                        'quality_preset': 'Medium',
                        'target_elements': 10000,
                        'max_size_mm': 100,
                        'curvature_adaptive': False
                    })

                    self.chatbox.update_mesh_data(mesh_data, self.cad_file, config)
                    print("[DEBUG] Chatbox updated with mesh data, CAD file, and config")

        else:
            self.add_log("=" * 70)
            self.add_log("MESH GENERATION FAILED")
            self.add_log(f"Error: {result.get('error')}")
            self.add_log("=" * 70)

    def on_ai_iteration_mesh_ready(self, mesh_path: str, metrics: Dict):
        """Called when an AI iteration completes - auto-display the mesh"""
        logging.info(f"on_ai_iteration_mesh_ready: {mesh_path}")

        if mesh_path and Path(mesh_path).exists():
            # Add to viewer's iteration list
            self.viewer.add_iteration_mesh(mesh_path, metrics)
            logging.info(f"Added iteration mesh to viewer: {mesh_path}")
        else:
            logging.warning(f"Mesh file not found: {mesh_path}")

    # Cross-section viewer methods
    def on_crosssection_toggled(self, state):
        """Enable/disable cross-section viewer"""
        enabled = (state == Qt.Checked)

        # Enable/disable controls
        self.clip_axis_combo.setEnabled(enabled)
        self.clip_offset_slider.setEnabled(enabled)

        # Apply or remove clipping
        if hasattr(self, 'viewer') and self.viewer:
            axis = self.clip_axis_combo.currentText().lower()
            offset = self.clip_offset_slider.value()
            self.viewer.set_clipping(enabled, axis, offset)

            if enabled:
                self.add_log(f"Cross-section enabled - Axis: {axis.upper()}, Offset: {offset}%")
            else:
                self.add_log("Cross-section disabled")

    def on_clip_axis_changed(self, axis_text):
        """Handle clip axis change"""
        if self.crosssection_enabled.isChecked() and hasattr(self, 'viewer') and self.viewer:
            axis = axis_text.lower()
            offset = self.clip_offset_slider.value()
            self.viewer.set_clipping(True, axis, offset)
            self.add_log(f"Cross-section axis changed to: {axis.upper()}")

    def on_clip_offset_changed(self, value):
        """Handle clip offset slider change"""
        self.clip_offset_value_label.setText(f"{value}%")

        if self.crosssection_enabled.isChecked() and hasattr(self, 'viewer') and self.viewer:
            axis = self.clip_axis_combo.currentText().lower()
            self.viewer.set_clipping(True, axis, value)

    # Paintbrush refinement methods
    def on_paintbrush_toggled(self, enabled: bool):
        """Handle paintbrush mode toggle"""
        if hasattr(self.viewer, 'interactor_style'):
            self.viewer.interactor_style.painting_mode = enabled

            if enabled:
                # Create brush cursor with current radius
                if self.paintbrush_widget:
                    radius = self.paintbrush_widget.get_current_radius()
                    self.viewer.create_brush_cursor(radius)
                self.add_log("Paintbrush mode enabled - Left click to paint, Right click to rotate")
            else:
                # Hide brush cursor
                if self.viewer.brush_cursor_actor:
                    self.viewer.brush_cursor_actor.VisibilityOff()
                    self.viewer.brush_cursor_visible = False
                    self.viewer.vtk_widget.GetRenderWindow().Render()
                self.add_log("Paintbrush mode disabled - Normal rotation mode")

    def on_brush_radius_changed(self, radius: float):
        """Handle brush radius change"""
        # Update brush cursor size if paintbrush is enabled
        if hasattr(self.viewer, 'interactor_style') and self.viewer.interactor_style.painting_mode:
            self.viewer.create_brush_cursor(radius)

    def on_refinement_changed(self, level: float):
        """Handle refinement level change"""
        pass  # Refinement level is stored in widget, used when painting

    def on_paint_at_cursor(self, x: int, y: int):
        """Handle painting at cursor position"""
        if not self.paintbrush_selector or not self.paintbrush_widget:
            return

        try:
            # Use cell picker to get actual surface point
            picker = vtk.vtkCellPicker()
            picker.SetTolerance(0.005)
            if not picker.Pick(x, y, 0, self.viewer.renderer):
                # No surface picked, skip painting
                return
            point = picker.GetPickPosition()

            # Get current brush settings
            radius = self.paintbrush_widget.get_current_radius()
            refinement = self.paintbrush_widget.get_current_refinement()

            # Find surfaces near point
            surfaces = self.paintbrush_selector.get_surfaces_near_point(point, radius)

            if surfaces:
                # Add painted region
                region = self.paintbrush_selector.add_painted_region(
                    surfaces, radius, refinement, center_point=point
                )

                # Update UI
                self.paintbrush_widget.add_region_to_list(
                    f"Region: {len(surfaces)} surfaces, {refinement:.1f}x"
                )

                # Update statistics
                stats = self.paintbrush_selector.get_statistics()
                self.paintbrush_widget.update_statistics(
                    stats['num_regions'],
                    stats['num_surfaces'],
                    stats['avg_refinement']
                )

                # Add visual marker at painted location
                self.viewer.show_paint_marker(point, radius)

                self.add_log(f"Painted {len(surfaces)} surfaces with {refinement:.1f}x refinement")

        except Exception as e:
            print(f"Error painting at cursor: {e}")

    def on_clear_painted_regions(self):
        """Clear all painted regions"""
        if self.paintbrush_selector:
            self.paintbrush_selector.clear_all_regions()
            if self.paintbrush_widget:
                self.paintbrush_widget.update_statistics(0, 0, 0.0)
            # Clear visual markers
            self.viewer.clear_paint_markers()
            self.add_log("Cleared all painted regions")

    def on_preview_refinement(self):
        """Preview refinement field (future enhancement)"""
        if self.paintbrush_selector:
            stats = self.paintbrush_selector.get_statistics()
            self.add_log(f"Preview: {stats['num_regions']} regions, "
                        f"{stats['num_surfaces']} surfaces painted")
            self.add_log(f"Avg refinement: {stats['avg_refinement']:.1f}x, "
                        f"Max: {stats['max_refinement']:.1f}x")

    def on_region_deleted(self, index: int):
        """Handle region deletion"""
        if self.paintbrush_selector:
            self.paintbrush_selector.remove_region(index)
            stats = self.paintbrush_selector.get_statistics()
            if self.paintbrush_widget:
                self.paintbrush_widget.update_statistics(
                    stats['num_regions'],
                    stats['num_surfaces'],
                    stats['avg_refinement']
                )
            self.add_log(f"Deleted region {index + 1}")

    def toggle_chatbox(self):
        """Toggle AI chatbox visibility and swap with left panel"""
        logging.info("="*60)
        logging.info("toggle_chatbox() called")
        logging.info(f"  chatbox = {self.chatbox}")
        logging.info(f"  chatbox_visible = {getattr(self, 'chatbox_visible', False)}")
        print(f"[DEBUG] toggle_chatbox called, chatbox={self.chatbox}, visible={getattr(self, 'chatbox_visible', False)}")

        if not self.chatbox:
            logging.warning("Chatbox is None - aborting toggle")
            print("[DEBUG] Chatbox is None, returning")
            return

        self.chatbox_visible = not self.chatbox_visible
        logging.info(f"New chatbox_visible state: {self.chatbox_visible}")
        print(f"[DEBUG] New chatbox_visible state: {self.chatbox_visible}")

        # Swap visibility between left panel and chatbox
        if self.chatbox_visible:
            logging.info("Opening chatbox...")
            print("[DEBUG] Opening chatbox...")
            self.left_panel.setVisible(False)
            self.chatbox.setVisible(True)
            self.chat_toggle_btn.setText("✕ Close Chat")
            self.chat_toggle_btn.setChecked(True)
            self.add_log("AI assistant opened - Ask Claude about your mesh!")
            logging.info("Chatbox opened successfully")
        else:
            logging.info("Closing chatbox...")
            print("[DEBUG] Closing chatbox...")
            self.chatbox.setVisible(False)
            self.left_panel.setVisible(True)
            self.chat_toggle_btn.setText("💬 AI Chat")
            self.chat_toggle_btn.setChecked(False)
            self.add_log("AI assistant closed")
            logging.info("Chatbox closed successfully")
        logging.info("="*60)


def main():
    app = QApplication(sys.argv)
    app.setStyle("Fusion")

    # Force light mode palette (prevents dark mode on macOS)
    palette = QPalette()
    # Window background
    palette.setColor(QPalette.Window, QColor(240, 240, 240))
    # Base (text input backgrounds)
    palette.setColor(QPalette.Base, QColor(255, 255, 255))
    # AlternateBase (alternating rows)
    palette.setColor(QPalette.AlternateBase, QColor(245, 245, 245))
    # ToolTipBase
    palette.setColor(QPalette.ToolTipBase, QColor(255, 255, 220))
    # ToolTipText
    palette.setColor(QPalette.ToolTipText, QColor(0, 0, 0))
    # Text (general text)
    palette.setColor(QPalette.Text, QColor(0, 0, 0))
    # Button
    palette.setColor(QPalette.Button, QColor(240, 240, 240))
    # ButtonText
    palette.setColor(QPalette.ButtonText, QColor(0, 0, 0))
    # BrightText
    palette.setColor(QPalette.BrightText, QColor(255, 255, 255))
    # Highlight (selections)
    palette.setColor(QPalette.Highlight, QColor(0, 120, 215))
    # HighlightedText
    palette.setColor(QPalette.HighlightedText, QColor(255, 255, 255))

    app.setPalette(palette)

    gui = ModernMeshGenGUI()
    gui.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
